视频地址：<https://www.bilibili.com/video/av18156598>
### 1.0 安装
客户端:TortoiseSVN:<https://tortoisesvn.net/>
服务端:VisualSVN:<https://www.visualsvn.com/server/download/>
## 一 linux系统
### 1. UNIX与Liux初步介绍
#### 1.1 linux发展历史
&emsp;1965年，美国麻省理工学院（MIT）、通用电气公司（GE）已AT&T（主营电话和电报）的贝尔实验室联合开发Multics工程计划，其目标是开发一种交互式的具有多道程序处理能力的分时操作系统，但因为Multics（在英文中就是大而复杂的意思）追求的目标过于庞大，项目管理不够完善（现在有PRINCE2），项目的进度远远落后与计划，最后贝尔实验室宣布退出。<br>
&emsp;1969年，美国贝尔实验室的肯.汤普森在DEC PDP-7机器上开发除了UNIX（原名UNICS）系统。注：写了一个游戏，但是运行比较慢，然后自己写了一个unix系统。TCP协议最早由斯坦福大学的两名研究人员于1973年提出。1983年,TCP/IP被Unix 4.2BSD系统采用.随着Unix的成功,TCP/IP逐步成为Unix机器的标准网络协议.Internet的前身ARPANET最初使用NCP(Network Control Protocol)协议,由于TCP/IP协议具有跨平台特性,ARPANET的实人员在经过对TCP/IP的改进以后,规定连入ARPANET的计算机都必须采用TCP/IP协议。随着ARPANET逐渐发展成为Internet,TCP/IP协议就成为Internet的标准连接协议。<br>
&emsp;1971年，肯.汤普森的同事丹尼斯.里奇发明了C语言（根据B语言），1973年，UNIX系统的绝大部分源代码用C语言重写，这为提高UNIX系统的可移植性打下了基础（芯片不同的不同，导致操作系统不好移植）。C语言和UNIX都获得了图灵奖。<br>

#### 1.2 UNIX的主要发行版本
操作系统 | 公司 | 硬件平台（CPU）
- | - | -
AIX | IBM| PowerPC（价格昂贵，没有硬件平台）
HP-UX | HP | PA-RISC
Solaris | Sun | SPARC
Solaris | Red Hat linux/Ubuntu Linux | Intel、AMD (类UNIX，个人电脑上可以使用）
&emsp;总的来说可以分为三个部分：System V家族，UNIX-386BSD家族（推荐freeBSD），UNIX-Like（推荐linux）。<br>
&emsp;最早的unix是开放的,很多组织对unix都有修改。期中比较有名的就是伯克利大学的修改版本,叫做bsd,是unix的分支,由于bsd的协议允许你直接使用\修改他的代码,并且可以作为商业用途,所以很多公司的unix都是从bsd衍生过来的,比如hp-unix,ibm的aix等等。linux呢,是一个完全没有参照unix代码的一个仿照unix架构,试图与unix相兼容的开源系统。换句话说,bsd是unix的分支,而linux是类unix系统或者说是仿unix系统。<br>

#### 1.3 linux发行版本
&emsp;Linux（借鉴Minix，作为教学使用）系统诞生于1991年，由芬兰大学生李纳斯（Linux Torvalds）和后来陆续加入的众多爱好者共同开发完成。Linux是开源软件，源代码开放的UNIX。内核官网：<www.kernel.org>。linux系统有linux内核和基于GNU协议的开源软件构成，也叫做GNU/Linux。
**主要发行版本**（主要的不同可能就在于软件安装的方式）
* **redhat（红帽子)**: CentOS（社区维护、免费）  Suse fedora（要服务费，个人版，测试版） 红旗 gentoo-linux
* **debian** ： ubuntu  KONPPIX

#### 1.4 linux开源软件简介
**开源软件**：apach Nginx MySQL php samba  mongoDB python Ruby Sphinx等，特点是：使用自由 研究自由 散布以及改良的自由（甚至销售）
支持互联网的开源技术（LAMP）
* Linux   操作系统
* Apache  Web服务器
* MySQL   数据库
* PHP     编程语言（后端）

#### 1.5 linux应用领域
（1）基于Linux的企业级服务器；
（2）嵌入式应用；  手机（android也是基于linux的。安装SSH可以操作）、平板电脑、智能家电、智能卡系统、航空系统、银行系统。
（3）Linux在电影娱乐业；
www.netcraft.com 可以用它查看服务器的系统等。

#### 1.6 linux学习方法
* 为什么使用命令行界面？  减少资源的使用，稳定性优先
* 解决问题的智慧？       帮助 文档 示例 查找
* GNU核心组件在线帮助    <http://www.gnu.org/software/coreutils/  >
* 学习方法              计划、坚持、专注、练习

#### 1.7 linux系统的安装
##### 1) VMware虚拟机
* VWware是一个虚拟PC的软件，可以在吸纳有的操作系统上虚拟出一个新的硬件韩欢，相当于模拟出一台新的电脑，以此在一台机器上真正同时运行两个独立的操作系统。官网： http://www.vmware.com
* 主要特点：
  * 不需要分区或重新开机就能在同一台PC上使用两种以上的操作系统
  * 本机系统可以与虚拟机系统网络通信
  * 可以设定并且随时修改虚拟机操作系统的硬件环境
* 要点：
  * 推荐低版本        VMware8.0.4  新版本占用空间太大
  * 新建虚拟机向导    建议创建一个虚拟空白硬盘（以后再安装操作系统）
  * 快照保存          可以恢复到保存的节点
  * 克隆模式          可以生成一个完全一样的虚拟系统，很方便

##### 2) linux系统的分区
* 主分区：最多只能有四个
* 扩展分区： 最多只能有一个、主分区加扩展分区最多只能有四个、不能写入数据只能包含逻辑分区
* 逻辑分区： 可以写入数据和格式化

&emsp;格式化（高级格式化）又称逻辑格式化。它是指根据用户选定的文件系统（如FAT16、FAT32、NTFS、EXT2、EXT3、EXT4等），在磁盘的特定区域写入特定的数据，在分区中划出一片用于存放文件的分配表、目录表等用于文件管理的磁盘空间。<br>
&emsp;inote。每个文件都有一个数据表，里面有很多inote节点号，记录了文件的存放位置。linux中 任何软件，硬件都看做文件比如：

设备 | 文件名
- | -
IDE硬盘 | /dev/hd[a-d] (老版，已经被淘汰)
SCSI/SATA/USB硬盘 | /dev/sd[a-p]
光驱 | /dev/cdrom 或 /dev/sr0
软盘 |  /dev/fd[0-1]
打印机(25针) | /dev/lp[0-2]
打印机(USB) | /dev/usb/lp[0-15]
鼠标 | /dev/mouse

分区挂载 <br>
**必须分区**
* /                （根分区）
* swap分区         （交换分区，内存的两倍，不超过2GB）

**推荐分区**
* /boot           （启动分区，200MB）防止根分区写满，系统无法启动

##### 3) 安装选项
CentOS安装欢迎界面选项： <br>

界面选项 | 说明
- | -
Install or upgrade an existing system | 安装或升级现有系统
Install system with basic video driver | 安装过程采用基本的显卡驱动
Rescue installed system | 进入系统修复模式
Boot from local drive | 退出安装从硬盘启动
Memory test | 存储介质检测

分区选择： <br>

分区类型 | 文件类型
- | -
先分boot分区 | 文件系统类型为ext4
再分swap分区（可选）| 文件系统类型为swap
再分根分区 | 文件系统类型为ext4

需要安装的软件： <br>

功能 | 说明
- | -
Desktop | 桌面 （个人用户选择）
Minimal Desktop | 最小化桌面
Minimal  | 最小化 （无图形界面，用作服务器选择，资源少稳定）
Basic Server | 基本服务器（安装好常用软件）
Database Server | 数据库服务器
Web Server | 网页服务器
Virtual Host | 虚拟主机
software development workstation | 软件开发工作站

&emsp;安装完以后，ls命令后发现当前是ROOT用户的根目录下（其它非root用户在home目录下），并且下面有三个文件。分别是：
* /root/install.log：存储了安装在系统中的软件包机器版本信息
* /root/install.log.syslog：  存储了安装过程中留下的事件记录
* /root/anaconda-ks.cfg：    以Kickstart配置文件的格式记录安装过程中设置的选项信息

#### 1.8 远程登录管理工具
虚拟机网络配置：
* 桥接       利用真实网卡，同一网段（设置），还可以和其它主机通信
* NAT        VMnet8，真实机可以访问外网，它就能。
* Host-only  VMnet1（虚拟网卡），只能和当前主机通信（没有网络也行）
ifconfig eth0 192.168.118.2（和VMnet8同一网段）
* 自定义

**远程连接工具（windows版）**
* SecureCRT
* Winscp  文件拷贝工具，传递数据，也可以使用（SSH）

#### 1.9 给初学者的建议-注意事项
* linux区分大小写。命令全是小写 文件名也全是小写
* 所有的内容全都是以文件形式保存的。包括硬件也是以文件形式保存的，不是以文件保存的都是临时生效。linux不靠扩展名区分文件类型，以下只是区分，并不是非要用这些扩展名：
  * 压缩包：“*.gz”、“*.bz2”、“*.tar.bz2”、“*.tgz”等
  * 二进制软件包： “.rpm”
  * 网页文件： “*.html”、“*.php”
  * 脚本文件： “*.sh”
  * 配置文件： “*.conf”
* linux靠文件权限来区分文件类型
* windows和linux无障碍交流的文件。包括ZIP压缩包，图片，视频，文本文件等。
* Linux所有的存储设备都必须挂载之后。用户才能使用，包括硬盘、U盘和光盘。（图形界面除外）

#### 1.10 服务器管理和维护建议-服务器管理和维护建议
**linux默认文件说明**
* /bin/。 存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式（有点像windows下的安全模式，启用最小的服务）下也可以执行
* /sbin/。保存和系统环境设置相关的命令，只有超级用户才可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看。
* /usr/bin/。存放系统命令目录，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行
* /usr/sbin/。存放根文件系统不必要的系统管理命令，例如多数服务程序。只有超级用户可以使用。大家其实可以注意到Linux的系统，在所有“sbin”目录中保存的命令只有超级用户可以使用，“bin”目录中保存的命令所有用户都可以使用
* /boot/。系统启动目录，保存系统启动相关文件，如内核文件和启动引导程序（grub）文件等。
* /dev/。设备文件保存位置。我们已经说过Linux中所有内容以文件形式保存，包括硬件，呢么这个目录就是用来保存所有硬件设备问价的
* /etc/。配置文件保存位置。系统内所有采用默认安装方式（rpm安装）的服务的配置文件全都保存在这个目录当中，如用户账户和密码，服务的启动脚本，常用服务的配置文件。
* /home/。普通用户的家目录。建立每个用户时，每个用户要有一个默认的登录位置，这个位置就是这个用户的家目录，所有普通用户的家目录就是在/home下建立一个和用户名相同的目录。如user1的家目录就是/home/useer1
* /lib/。系统调用的函数库保存位置
* /lost+found/。当系统义务外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是跟分区的备份恢复目录，/boot/lost+found就是/boot分区的备份恢复目录。
* /media/。挂载目录。系统建议用来挂载媒体设备的，例如光盘和软盘
* /mnt/。挂载目录，早期Linux中只有这一个挂载目录，并没有细分。现在这个目录系统建议挂载额外设备，如U盘，移动硬盘和其他操作系统的分区。
* /misc/ 。挂载目录。系统建议用来挂载NFS服务的共享目录，我们在刚刚已经解释了挂载，一个已经建立的空目录就可以作为挂载点。那么系统虽然准备了三个默认挂载目录/media，/mnt，/misc，但是到底哪个目录挂载什么设备都可以由管理有自己决定。例如超过接触linux的时候，默认挂载目录只有/mnt一个，所以养成了在/mnt下建立不同目录挂载不同设备的习惯
* /opt/。第三方安装的软件保存位置。这个目录就是防止和安装其他软件的位置，我手工安装的源码包软件都可以安装到这个目录当中。不过我还是习惯把软件放置到/usr/local目录中，也就是说/usr/local目录也可以用来安装软件。
* /proc/。虚拟文件系统，该目录中的数据并不保存到硬盘当中，而是保存到内存当中。主要保存系统的内核，进程，外部设备状态和网络状态灯。比如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动列表的，/proc/filesystems是保存文件系统列表的，/proc/net是保存网络协议信息的。
* /sys/。虚拟文件系统。和/proc类似，都是保存在内存当中的，主要是保存于内核相关信息的。
* /root/。超级用户的家目录。普通用户家目录中/home目录下
* /srv/。服务器目录数据。一些系统服务启动后，可以在这个目录中保存所需要的数据
* /tmp/。临时目录。系统存放临时文件的目录，该目录下所有用户都可以访问和写入。我们建议此目录中不能保存重要数据，最好每次开机都把该目录清空。
* /usr/。系统软件资源目录。注意usr不是user的缩写，而是“Unix Software Resource”的缩写，所以不是存放用户数据而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里，所以除了/usr/bin和/usr/sbin这两个目录，在介绍几个/usr下的二级目录
* /var/。动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件。

**服务器注意事项**
* 远程服务器不允许关机，只能重启。远程服务器，关机了不好再开启
* 重启时应该关闭服务。大容量数据，强制关机容易引起错误
* 不要在服务器访问高峰期运行高负载命令
* 远程配置防火墙时不要把自己踢出服务器
* 指定合理的密码规范并定期更新
* 分配合理的权限
* 定期备份重要数据和日志

### 2. linux软件包管理
#### 2.1 软件包分类
* 源码包。脚本安装包（大多数是c和c++写的），像linux.iso等，编译时间比较长，编译过程中一旦报错，新手很难解决。
* 二进制包。RPM包、系统默认包，经过编译后的安装包，安装简单。节约时间，但是不能看到源代码。CentOS里所有的二进制包都是RPM包。

#### 2.2 RPM包管理-rpm命令管理方式
**1）命名规则**
httpd-2.2.15-15.e16.ecntos.1.i686.rpm <br>
说明如下：

字段 | 介绍
- | -
httpd | 软件包名
2.2.15 | 软件版本
15 | 软件发布的次数
e16.centos | 适合的Linux平台
i686 | 适合的硬件平台（分为86版和64版）
rpm |rpm包的扩展名

**2）依赖规则**
* 树形依赖：  a->b->c
* 环形依赖：  a->b->c->a
* 模块依赖：  查询网站 ww.rpmfind.net（可以查询库文件属于哪个包）

rpm -ivh  完整rpm包名（在CentOS镜像里package下有所有的包）

**3）常用命令** <br>
&emsp;包全名：操作的包是没有安装得到软件包时，使用包全名。而且要注意路径。 <br>
&emsp;包名：操作已经安装的软件包时，使用包名。是搜索/var/lib/rpm/中的数据库。 <br>
``` text
命令名称：rpm   （常用来查询）
选项：
  -i（install）安装
  -U（upgrade）升级
  -e（erase）  卸载，根据依赖性全部卸载，
  -v           显示详细信息
  -h           显示进度
  -q           查询
  -l           查询包的安装路径
  -f           查询系统文件属于哪个软件包
  -R           查询软件包的依赖性
  -V           校验指定RPM包中的文件有没有修改（一般是配置文件）
  --nodeps     不检测依赖性
方式：
  rpm -qa                查询所有已安装的rpm包
  rpm -q 包名            查询包是否安装
  rpm -qa | grep httpd   列出所有和apache相关的包（已安装）
  rpm -qi                查询软件安装信息
  rpm -qip               查询未安装包信息（没有安装该包也可以查询，但必须是包全）
  rpm -ql                查询已安装包的安装位置
  rpm -qlp               查询未安装包的安装位置
  rpm -qf 系统文件名      查询系统文件属于哪个软件包
  rpm -qR 包名           查询软件包依赖性
  rpm -qRp 包全名         查看未安装软件包依赖性
  rpm -ivh httpd-2.2.15-15.e16.ecntos.1.i686.rpm    安装apache主包
```

``` text
验证内容的8个信息:
  s      文件大小是否改变
  M      文件的类型或权限(rwx)是否被改变
  5      文件的MD5校验和是否改变(可以看成文件的内容是否改变)
  D      设备的中，从代码是否改变
  L      文件路径是否改变
  U      文件的属主(所有者)是否改变
  G      文件的属组是否改变
  T      文件的修改时间是否改变
文件类型:
  c      配置文件（config file）
  d      普通文档（documentation）
  g      鬼文件（ghost file）
  l      授权文件（license file）
  r      描述文件（read file）
```

将rpm包转换为cpio格式的命令:
``` text
命令： rpm2cpio   包全名
```

创建软件档案文件和从档案文件中提取文件:
``` text
命令： cpio         
方式：
    cpio 选项<[文件|设备]
    rpm2cpio  包全名 | cpio -idv .文件绝对路径  从安装包里提取相应的文件到当前目录下。
选项：
-i     copy-in模式，还原
-d    还原时自动新建目录
-v     显示还原过程
```

#### 2.3 yum在线管理
yum在线管理可以自行解决依赖性（通过服务器，也可以通过ISO镜像）
IP地址配置和网络yum源
访问内网，只需要IP和子网掩码，但访问公网还需要网关和DNS
* 1 红帽子setup工具先配置网络
* 2 启动网卡
  在/etc/sysconfig/network-scripts/ifcfg-eth0中将ONBOOT=“no”改为“yes”。注意没有setup工具也是通过该文件设置网络的
* 3 重启网络服务

``` bash
services network restart
```

**网络yum源**：在/etc/yum.repos.d/CentOS-Base.repo文件中，里面有很多yum源，默认第一个生效。/etc/yum.repos.d文件夹下有各种repo，默认CentOS-Base生效。
* [base]       容器名称，一定要在[]中
* name         容器说明，可以自己随便写
* mirrorlist   镜像站点，这个可以注释掉     
* baseurl      我们的yun源服务器的地址。默认是CentOS 官方的源服务器，是可以使用的，如果你觉得慢可以改成你喜欢的yun源地址。
* enabled      此容器是否生效，如果不写或写成enable=1都是生效，写成enable=0就是不生效
* gpgcheck     如果是1是指RPM的数字证书生效，如果是0则不生效
* gpgkey        数字证书的公钥文件保存位置。不用修改   

yum命令：
``` text
命令： yum
方式：
    yum install package_name           安装指定软件包
    yum remove  package_name           卸载指定软件包
    yum update  package_name           更新指定软件包  
    yum list                           列出所有可安装的软件清单命令
    yum search  <keyword>              查找软件包
    yum update                         更新所有软件包
    yum check-update                   列出所有可更新软件包  
    yum grouplist                      列出所有可用软件组列表
    yum groupinstall 软件组名          安装指定软件组（其实就是系统安装过程中选择的指定安装，我们选的是最小安装）
    yum groupremove  软件组组名        卸载指定软件组             
选项：
-y      不询问，一律同意
```

**光盘yum源搭建**：以光盘中的RPM包作为源使用yum管理
* 1）挂载光盘
``` bash
   mount /dev/cdrom  /mnt/cdrom/
```
* 2）让网络yum源文件失效。
  * 删除yum.repos.d下的CentOS_Base.repo等文件，只留下CentOS-Media.repo这个媒体源
* 3）修改光盘yum源文件，并使之生效，修改CentOS-Media.repo如下(主要要修改的是baseurl，enabled）：
``` text
[c6-media]
name=CentOS-$releasesever - Media
baseurl=file:///mnt/cdrom
gpgcheck=1
enabled=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
```

注：linux有些配置文件有严格的要求，注释符号只能在每行的开头，不能缩进，也不能在某些关键行的后面添加注释说明

#### 2.4 源码包管理

##### 有何区别？之前讲过安装之前的区别，现在介绍一下安装位置的不同？
**1）安装位置**
* RPM包是安装在默认位置的
``` text
/etc/           配置文件安装目录
/usr/bin/       可执行命令安装目录
/usr/lib/       程序所使用的函数库保存位置
/usr/share/doc/ 基本的软件使用手册保存位置
/uer/share/man/ 帮组文件保存位置
```
* 源码包一般是手工指定安装位置，习惯在：
``` text
/usr/local/软件名/    软件安装位置
/uer/local/src/       源代码保存位置
```

**2)服务管理**
* RPM包安装的服务可以使用系统服务管理命令（service）来管理（包括启动，停止以及重新启动），例如RPM包安装的apache的启动方法有两种：
``` text
/etc/rc.d/init.d/httpd start
service httpd start    
```
* service能管理是因为会在RPM默认的路径里搜索相关服务，但源码包的安装位置并不相同，所以service不能管理源码包安装的软件。这样就会导致一个问题，我们用RPM包安装好一个软件之后，仍然可以使用源码包安装同样的软件，因为安装位置的不同并不会引起冲突。
当然我们如果用源码包吧apache安装在了/usr/local/apache下，应该使用：
``` text
/usr/local/apache/bin/apachectl start 来启动服务
```

**源码包安装过程**
* 安装准备
  * 安装c语言编译器
  * 下载源码包。<http:/mirror.bit.edu.cn/apache/httpd>
* 安装注意事项。安装过程中报错条件：
  * 安装过程停止
  * 出现error、warning或no的提示
* 源码包安装过程
  * 下载软件包，并放在linux中
  * 解压软件包
  * 进入源码包目录
  * 查看INSTALL和README这两个文件，以获得安装帮助
  * ./configure  软件配置与检查（编译前的准备，使用./configure --help查看具体配置）。
``` text
       定义需要的功能选项
       检测系统环境是否符合安装要求
       把定义好的功能选项和检测系统环境的信息都写入Makefile文件（makefile编译控制比较难学，跨平台使用cmake），用于后续的编辑
```
  * make 编译源码包，该命令并没有真正安装（需要重新编译时，make clean 可以清除编译过程中产生的中间文件）
  * make install 编译安装
* 删除命令。
  * 直接删除 /usr/local/apache这个目录就可以了，源码编译命令会把所有相关的文件全部安装在该文件夹下，删除掉不会遗留任何信息。而安装也不需要重新编译，make install可以重新安装

**linux软件包管理-脚本安装**（主要是硬件驱动，驱动安装比较麻烦）<br>
**什么是脚本安装** <br>
* 脚本安装包并不是独立的软件包类型，常见安装的是源码包
* 是人为把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装
* 非常类似于Windows下软件的安装的方式。

**Webmin的作用** <br>
Webmin是一个基于Web的Linux系统管理界面。您就可以通过图形化的方式设置用户账号、Apache、DNS、文件共享等服务 <br>
Webmin安装过程
* 下载软件。<http://sourceforge.net/projects/webadmin/files/webmin/>
* 解压缩，并进入压缩目录
* 执行安装脚本setup.sh

###  3. 用户和用户组管理
#### 3.1 用户管理简介
* 所以越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范。
* 在linux中主要通过用户配置文件来查看和修改用户信息

#### 3.2 用户配置文件-信息文件/etc/passwd
说明：可以使用 man 5 passwd 来查看帮助
* 第一字段： 用户名称
* 第二字段： 密码标志 并没有将密码放在这里，是放在影子文件中的（当然需要进行加密）
* 第三字段： UID(用户ID)
``` text
0          超级用户
1-499      系统用户（伪用户）,删除系统就崩溃了
500-65535  普通用户
```
* 第四个字段： GID（用户初始组ID）
``` text
初始组：就是指用户一登陆就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用户名相同的组名作为这个用户的初始组。建议不去下修改，默认就是属于自己这个组。
附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。
```
* 第五个字段： 用户说明
* 第六个字段： 家目录
* 第七个字段： 登陆之后的Shell
``` text
Shell就是Linux的命令解释器。在/etc/passwd当中，除了标准的Shell是/bin/bash之外，还可以写入/sbin/nologin（不能登录了）。
```

#### 3.3 用户配置文件-影子文件/etc/shadow
* 第一个字段：用户名
* 第二个字段：加密密码。加密算法升级为SHA512散列加密算法。如果密码位是“!!”或是“*”代表没有密码，不能登录
* 第三个字段：密码最后一次修改时间。使用1970年1月1日作为标准时间，每过一天时间戳加1
* 第四个字段： 两次密码的修改间隔时间（和第三字段相比）
* 第五个字段： 密码有效期（和第三个字段相比）
* 第六个字段： 密码修改到期前的警告天数（和第五字段相比）
* 第七个字段： 密码过期的宽限天数（和第五个字段相比）0表示密码过期后立即失效，-1表示密码永远不会失效
* 第八个字段： 账号失效时间（要用时间戳表示），密码有效期会被覆盖
``` bash
       date -d "1970-01-01 16066 days"   #时间戳换算为日期
       echo $(($(date --date="2014/01/06"+%s)/86400+1)) #把日期换算成时间戳
```
* 第九个字段： 保留

#### 3.4 用户配置文件-组信息文件/etc/group和组密码文件/etc/gshadow
* 说明：组信息文件/etc/group
``` text
第一字段： 组名
第二字段： 组密码标志
第三字段： GID
第四字段： 组中附加用户
```
* 说明：组密码文件/etc/gshadow
``` text
第一字段： 组名
第二字段： 组密码
第三字段： 组管理员用户名
第四字段： 组中附加用户
```
* 用户管理相关文件（添加用户后自动生成的）
``` text
1）用户的家目录
2）用户的邮箱 /var/spool/mail/用户名/ (用户之间的邮箱，和咱们日常使用的邮箱概念不同）
3）用户的模板目录 /etc/skel/。用户创造时根据模板在家目录下生成一系列文件（默认是影藏文件）
```

#### 3.5 用户管理命令  useradd passwd  usermod change userdel su
**命令：useradd**
``` bash
方式：
     useradd [选项名] 用户名
     useradd -u 550 -G root,bin -d /home/lamp1 -c "test user" \
-s /bin/bash taochao       #添加一个新用户taochao
选项：
    -u UID        #手工指定用户的UID号
    -d 家目录     #手工指定用户的家目录
    -c 用户说明   #手工指定用户的说明（相当于额外备注）
    -g 组名       #手工指定用户的初始组
    -G 组名       #指定用户的附加组
    -s shell      #手工指定用户的登陆shell。默认是/bin/bash
```
**注:用户默认值文件**
``` text
/etc/default/useradd中：
    GROUP=100             用户默认组（公有模式）
    HOME=/home            用户家目录
    INACTIVE=-1           密码过期宽限天数（shadow文件7字段）
    EXPIRE=               密码失效时间（第8个字段）
    SHELL=/bin/bash       默认shell
    SKEL=/bin/skel        模块目录
    CREATE_MALL-SPOOL=yes 是否建立邮箱
/etc/login.defs中：
    PASS_MAX_DAYS   99999   密码有效期
    PASS_MIN_DAYS   0       密码修改间隔
    PASS_MIN_LEN    5       密码最小5位(PAM)
    PASS_WARN_AGE   7       密码到期警告（6）
    UID_MIN         500     最小和最小UID范围
    GID_MAX         60000  
    ENCRYPT_METHOD  SHA512  加密模式
````

**命令：passwd**    给用户设置密码
``` bash
方式：
  passwd [选项]  用户名   #注意：只有超级用户才加用户名
  echo "123"|passwd --stdin lamp  #将123设置成密码，多用于shell编程。
选项:
  -S          #查询用户密码的密码状态。仅root用户可用
  -l          #暂时锁定用户。仅root用户可用
  -u          #解锁用户。仅root用户可用
  --stdin     #可以通过管道符输出的数据作为用户的密码。
```
**命令：usrermod**  针对已经存在的用户，修改其参数
``` bash
方式：
  和useradd基本一样
选项：
  -L           #锁定用户
  -U           #解锁用户
```

**命令：chage**    修改用户密码状态
``` bash
方式：
  chage [选项] 用户名
  chage -d 0 taochao  #修改日期归0，这样用户一旦登录就需要更改密码
选项：
  -l          #列出用户的详细密码状态
  -d 日期     #修改密码最后一次更改日期（shadow3字段）
  -m 天数     #两次密码修改间隔
  -M 天数     #密码有效期
  -W 天数     #密码过期前警告天数
  -l 天数     #密码过期后宽限天数
  -E 日期     #账号失效时间（shadow8字段）
```

**命令：userdel**
``` bash
方式：
  userdel 用户名        #删除用户但保留家目录
  userdel -r 用户名     #删除用户同时删除家目录
```
注：手工删除目录需要修改前面提到的所有用户管理文件

**命令：id**           查看用户的ID（用户ID,初始ID，附加组ID）
``` bash
方式：
  id  username       
选项
```

**命令：su**         切换用户身份
``` bash
方式：
  su [选项]  用户名
  su - root -c "useradd user3"  #添加一个新用户，但不切换用户。
选项：
  -        #选项只用"-"代表连带用户的环境变量一起切换，用env命令可以查看当前环。
  -c 命令    #仅执行一次命令，而不切换用户身份
```

#### 3.6 用户组管理命令
**命令：groupadd**        添加用户组
``` bash
方式：
  group [选项] 组名
选项：
  -g GID         #指定组ID
```

**命令：groupmod**      修改用户组
``` bash
方式：
  groupmod [选项] 组名
选项：
  -g  GID        #修改组ID
  -n  新组名     #修改组名
```

**命令：groupdel**         删除用户组。当组为某个用户的初始组时不可用
``` bash
方式：
  groupdel 组名
```
**命令：gpasswd**     把用户添加入组或是从组中删除
``` bash
方式：
  gpasswd  选项  组名
  gpasswd -d user1 root   #将user1从root组中删除
选项：
  -a  用户名      #把用户加入组
  -d  用户名      #把用户从组中删除
```

#### 3.7 权限-ACL权限
##### 3.7.1 权限-ACL权限-简介
&emsp;不考虑文件所属用户和所数组，直接给予某个用户相应的权限，类似于windows的权限管理方式。<br>
**查看分区ACL权限是否开启**
``` bash
方式：
  dumpe2fs -h /dev/sda3    #dumpe2fs命令是查询指定分区详细文件系统信息的命令。
选项：
  -h      #仅显示超级块中信息，而不显示磁盘块组的详细信息
```
注：在Default mount options中查看，事实上默认都是支持的
**开启**
* 1）mount -o remount,acl  重新挂载根分区，并挂载加入acl权限。这个是临时生效。
* 2）修改etc/fstab文件。系统开机自动挂载文件。改为:
``` text
UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 default,acl 1 1
```
然后重新挂载文件系统使修改生效
``` bash
mount -o remount /
```

##### 3.7.2 ACL权限-查看与设定
**命令：getfacle**
``` bash
方式：
  getfacle  文件名       # 查看acl权限
```

**命令：setfcal**               设定ACL权限的命令
``` bash
方式：
  setfacl  选项  文件名
  setfacl -m u:st:rx /project/ #使用“u:用户名:rx”的格式。给用户设定acl权限。
  setfacl -m g:tgroup2:rwx /project/  #给组非配ACL权限
  setfcal -m m:rx  /project/          #设定mask最大权限
  setfacl -x u:用户名  文件名         #删除指定用户的ACl权限
  setfacl -x g:组名   文件名          #删除指定用户组的ACL权限
  setfacl -d 文件名                   #删除文件的所有ACL权限
  setfacl -m u:用户名:权限 -R 目录名  #递归设置ACL权限（注意这个命令选项顺序不可改变），只针对已经存在过的文件，对后面新建的文件不起1作用。
  setfacl -m d:u:用户名:权限 -R 目录名   #与上面不同，ACL权限可以传给新建在该目录下的子文件。
选项：
  -m       #设定ACL权限
  -x       #删除指定的ACL权限
  -b       #删除所有的ACL权限
  -d       #设定默认ACL权限
  -k       #删除默认的ACL权限
  -R       #递归设定ACL权限
```
##### 3.7.3 权限-ACL权限-最大有效权限mask与删除
&emsp;mask是用来指定最大有效权限的。如果我给用户赋予了ACL权限，是需要和mask的权限“相与”才能得到用户的真正权限。它的设置会影响ACL权限和所有组权限，但不会影响到所有者权限。<br>

##### 3.7.4 权限-ACL权限-默认与递归ACL权限
&emsp;递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限。
默认ACL权限的作用是如果给父目录设定了默认ACL权限，那么父目录中所有新建的子文件都会继承父目录的ACL权限。<br>

#### 3.8 权限-文件特殊权限-SetUID
需要注意的几点：
* 只有可以执行的二进制程序才能设定SUID权限
* 命令执行者要对该程序拥有x（执行）权限
* 命令只想你跟着在执行该程序时获得该程序文件属主的身份（在执行程序的过程中灵魂附体为文件的属主）
* SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效

&emsp;用ls -l 查看文件的详细属性时，如果有s执行权限，则代表该文件有文件特殊权限。
我们都知道普通用户拥有写修改自己密码的权利，但是记录密码的文件是/etc/shadow，普通用户没有任何权限。这个时候就需要给passwd添加文件特殊权限，使得它在运行过程中短暂获得root权限。<br>

设定SetUID的方法:
``` bash       
chmod 4755 文件名      
chmod u+s 文件名  
```     
清除SetUID的方法:
``` bash
chmod 755 文件名
chmod u-s 文件名
```
注意：关键目录应严格控制写权限。比如“/”，“/usr”等。用户的密码设置要严格遵守密码三原则。对系统中默认应该具有SetUID权限的文件作一列表，定时检查有没有这之外的文件被设置了SetUID权限。

#### 3.9 权限-文件特殊权限-SetGID
**1) 针对可执行二进制程序**
* 只有可执行的二进制程序才能设置SGID权限
* 命令执行者要对该程序拥有x（执行）权限
* 命令执行在执行程序的时候，组身份升级为该程序文件的属组
* SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效。

``` bash
chmod g+s 可执行文件
chmod 2755  可执行文件
```
**2）针对目录的作用**
* 普通用户必须对此目录拥有r和x权限，才能进入此目录
* 普通用户在此目录中的有效组会变成此目录的属组
* 若普通用户对此目录拥有w权限时，新建的文件的默认属组是这个目录的属组

比如locate命令：<br>
/usr/bin/locate 的权限是-rwx--s--x  <br>
/var/lib/mlocate/mlocate.db 的权限是 -rw-r-----   <br>

``` bash
chmod g+s  目录名
chmod 2755 目录名
```
#### 3.10 权限-文件特殊权限-Sticky BIT
* 黏着位目前只对目录有效
* 普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限
* 如果没有黏着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一旦赋予了黏着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。

例如：在/tmp/目录中就设置了SBIT权限，除了根用户之外，每个用户只能删除自己创建的文件。
设置黏着位:
``` text
chmod 1755 目录名      
chmod o+t  目录名   
```   
取消黏着位:
``` text
chmod 755 目录名
chmod o-t 目录名
```

#### 3.11 权限-chattr权限
**命令：chattr**    给文件设置权限，该权限可以限制root用户
``` bash
方式：
  cahttr [+-=] [选项] 文件或者目录
选项：
  i   #如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能你添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删除文件。
  a   #如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除。
```

**命令：lsattr**    查看文件系统属性
``` bash
方式：
   lsattr 选项 文件名
选项：
-a     #显示所有文件和目录
-d     #若目标是目录，仅列出目录本身的属性，而不是子文件的
```

#### 3.12 权限-系统命令sudo权限
sudo 权限：
* root把本来只能超级用户执行的命令赋予普通用户执行。
* sudo的操作对象是系统命令

**命令：visudo** <br>
注：该命令实际上修改的是/etc/sudoers文件,不使用该命令，直接修改改文件也是可以的。实际过程中不能给VIM赋予sudo权限（尽管普通用户可以使用vim命令，但是一旦变成root用户执行，就能够修改系统关键的配置文件）<br>
给某个用户赋予权限：
``` text
root                  ALL=(ALL)                  ALL
#用户名   被管理主机的地址=（可使用的身份）  授权命令（绝对路径）
```
给某个用户组赋予权限：
``` text
%wheel                ALL=(ALL)                  ALL
#%组名     被管理主机的地址=（可使用的身份）   授权命令（绝对路径）
```
(ALL)一般不写，通常默认为root用户 <br>
taochao ALL= /sbin/shutdown -r now  给用户taochao重启计算机的权限 <br>

**命令：sudo**
``` bash
方式：
  sudo -l                   #查看能够使用的超级命令
  sudo 命令（绝对路径）      #执行超级命令
```

### 4. 文件系统管理
#### 4.1 文件系统管理-文件系统介绍
* ext2：是ext文件系统的升级版本，RedHat Linux7.2版本以前系统默认都是ext2文件系统。1993年发布，最大支持16TB的分区和最大2TB的文件。
* ext3：ext3文件系统是ext2文件系统的升级版本，最大的区别就是带日志功能，以在系统突然停止时提高文件系统的可靠性。支持最大16TB的分区和最大2TB的文件。
* ext4：它是ext3文件系统的升级版。ext4在性能、伸缩性和可靠性方面进行了大量改进。ext4的变化可以说是翻天覆地的，比如向下兼容EXT3、最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等。是CentOS6.3的默认文件系统。

#### 4.2 文件系统管理-文件系统常用命令-查看命令
``` bash
**命令：df**           统计分区详细信息
方式：
  df [选项] [挂载点]
选项：
  -a   #显示所有文件系统信息，包括特殊文件系统，如/proc、/sysfs
  -h   #使用习惯单位显示容量，如KB，MB，或GB等
  -T   #显示文件系统类型
  -m   #以MB为单位显示容量
  -k   #以KB为单位显示容量（默认）
```
**命令：du**           统计目录和文件大小
``` bash
方式：
  du [选项] [目录名或文件名]
选项：
  -a   #显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量。
  -h   #使用习惯单位显示磁盘占用量，如KB，MB或GB等
  -s   #统计总占用量，而不列出子目录和子文件的占用量
```
du和df命令的区别
* df命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间），df看到的空间才是系统真正剩余的空间。
* du命令是面向文件的，只会计算文件或目录占用的空间。

**命令：fsck**       文件系统修复命令fsck（系统在开机时会自动检测，不需要过多关注）
``` bash
方式：
  fsck [选项] 分区设备文件名
选项：
  -a    #不用显示用户提示，自动修复文件系统
  -y    #自动修复。和-a作用一致，不过有些文件系统只支持-y
```

**命令：dumpe2fs**     显示磁盘状态命令
``` bash
方式：
    dumpe2fs /dev/sda1   #查看主分区1的磁盘状态
```

#### 4.3 文件系统管理-文件系统常用命令-挂载命令
**命令：mount**
``` bash
方式：
  mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点
  mount -l  #查询系统中已经挂载的设备，-l会显示卷标名称
  mount -a  #一句配置文件/etc/fstab的内容自动挂载（系统启动的时候可以自动挂载）
  mount -o remount,noexex /home #重新挂载/home分区，使用用noexec权限，这时home分区将不能执行文件（哪怕是root用户）。
选项：
  -t 文件系统  #加入文件系统类型来指定挂载的类型，有ext4，iso9660等。如果是windows的分区，fat32为vfat,fat16为fat。
  -L  卷标名   #挂载指定卷标的分区，而不是安装设备文件名挂载，可以不写。
  -o 特殊选项  #可以制定大概挂载的额外选项。选项比较多（remount，exec/noexec），自己查看。
```
设备挂载示例：
* 1）挂载光盘
  * 建立挂载点
``` bash
mkdir  /mnt/cdrom/
```
  * 挂载光盘
``` bash
mount -t iso9660 /dev/cdrom /mnt/cdrom/
#或
mount /dev/sr0 /mnt/cdrom/
```

* 2）挂载U盘
``` bash
fdisk -l       #先查看u盘（也可以其他硬盘哦）的设备文件名
mount -t vfat /dev/sdb1 /mnt/usb/   #挂载U盘
```
注：linux默认是不支持NTFS文件系统的

* 3）如何使用支持NTFS系统的U盘。linux中默认是没有预先安装NTFS格式的驱动的。
  * 重新编译内核，加载NTFS驱动。
  * 利用第三方插件。<http://www.tuxera.com/community/ntfs-3g-download/>。下载源码包后，编译并安装。
  * mount -t ntfs-3g 分区设备文件名 挂载点

**命令：umount**         卸载命令
``` bash
方式：
  umount  设备文件名或挂载点
  umount  /mnt/cdrom               #卸载光驱
```

#### 4.4 文件系统管理-fdisk分区
**命令：fdisk**          使用fdisk查看和建立分区
``` bash
方式：
  fdisk -l         #查看所有硬盘以及硬盘分区
  fdisk /dev/sdb   #给sdb进行分区（还没分区不能添加序号）
选项：
  d     #删除一个分区（重要）
  l     #设置已知的文件系统类型。82为Linux swap分区，83为Linux分区（重要）
  m     #显示帮助菜单（重要）
  n     #新建分区（重要）
  t     #改变一个分区的系统ID（重要）
  w     #保存退出（重要）
  q     #不保存退出（重要）
  p     #显示分区列表（重要）
  a     #设置可引导标记
  b     #编辑bsd磁盘标签
  c     #设置DOS操作系统兼容标记
  o     #建立空白DOS分区表
  s     #新建空白SUN磁盘标签
  u     #改变显示记录单位
  x     #附加功能
```

**命令：partprobe**      重新读取分区表信息  <br>
注：分区完成之后需要重启，可以使用这个命令避免重启过程。  <br>

**命令：mkfs**    建立分区之后再用此命令格式化分区（扩展分区不能格式化，它只是一个容器）
``` bash
方式：
  mkfs -t ext4 /dev/sdb1
```

**接下来**就像前面讲过的：
``` bash
mkdir /disk1             #新建挂载点
mount /dev/sdb1 /disk1/  #挂载硬盘
```
注：fdisk能查询分区是否正常分配，而df和mount可以查询分区是否被挂载。但是通过这种方式每次重启服务器的时候，都需要手动挂载。<br>

**分区自动挂载与fstab文件修复**<br>
自动挂载文件/etc/fstab（重要系统启动资源文件，如果写错系统就崩溃了）
* 第一字段：分区设备文件名或UUID（硬盘通用唯一识别码）
* 第二字段：挂载点
* 第三字段：文件系统名称（默认ext4,swap）
* 第四字段:   挂载参数（和 mount 挂载的属性差不多）    
* 第五字段：指定分区是否被 dump 备份，0 代表不备份，1 代表每天备份，2 代表不定期备份。lost+found 就是每个分区目录下的默认备份目录。
* 第六字段：指定分区是否被 fsck 检测，0 代表不检测，其他数字代表检测的优先级，那么当然 1 的优先级比 2 高。/分区是 1，/boot 分区和/home 分区都是 2。
例如在该文件中添加一行：
``` text
/dev/sdb1 /disk1 ext4 defaults 1 2
```
保存上诉文件，并退出，然后运行：
``` bash
mount -a
```

#### 4.5 Linux  服务管理- 服务分类
&emsp；linux 服务分为RPM包默认安装服务和源码包安装服务，前者又分为独立服务和基于xinetd 服务。独立服务就在内存中，能快速相应用户的请求，但是耗费资源；xinet 相当于一个代理服务，响应速度比较慢。<br>
服务启动与自启动:
* 服务启动：就是在当前系统中让服务运行，并提供功能。
* 服务自启动：自启动是指让服务在系统开机或重启动之后，随系统的启动而自动启动服务。
查看已安装的服务:
* RPM 包安装的服务：chkconfig --list （查看自启动级别，ps 查看进程）。由于 RPM 包有默认安装位置，配置文件在/etc/下，启动脚本在/etc/rc.d/init.d 下。
* 源码包安装的服务：/usr/local 下

##### 4.5.1 RPM 服务管理-独立服务管理
###### 1）RPM默认安装位置：
``` text
/etc/init.d/ 启动脚本位置
/etc/sysconfig/ 初始化环境配置文件位置
/etc/ 配置文件位置
/etc/xinetd.conf xinetd 配置文件
/etc/xinetd.d/ 基于 xinetd 服务的启动脚本
/var/lib/ 服务产生的数据放在这里
/var/log/ 日志
```

###### 2）服务的启动:
``` bash
* services --status-all                                    #所有RPM包的运行状态
* /etc/init.d/独立服务名 start|stop|status|restart         #绝对路径启动
* services 独立服务名 start|stop|status|restart            #
```

###### 3）独立服务的自启动（推荐第二种方法）
* chkconfig [--level 运行级别] [独立服务名] [on|off]
* 修改/etc/rc.d/rc.local 文件。该文件的内容在登陆过程之前运行（开机软件等运行结束）。
* 使用 ntsysv 命令管理自启动（图形化界面）。可以设置两种服务。

###### 4）RPM 服务管理-基于 xinetd 服务管理
安装 xinetd 与 telnet（不常用，默认不装，也没多大用处）<br>
``` bash
yum -y install xinetd        #不装就看不到基于 xinetd 的服务
yum -y install telnet-server
```
##### 4.5.2 源码包服务的管理
###### 1) 源码包安装服务的启动
&emsp;使用绝对路径。调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法。源码包安装的服务需要仔细查看README和INSTALL文件，查看安装位置和启动方法。<br>
例： /usr/local/apache2/bin/apache                   <br>
* 源码包的自启动
    修改 /etc/rc.d/rc.local 文件
* 让源码包服务能够被 service 识别
   设置软连接
* 让源码包的 apache 服务能被 chkconfig 与 ntsysv 命令管理自启动
   /etc/rc.d/文件下有很多文件，S 代表启动顺序，K 代表关闭顺序
* 修改 /etc/init.d/apache 文件
``` text
#chkconfig: 35 86 76                     #格式：运行级别 启动顺序 关闭顺序
#description:source package apache       #说明，内容随意
```
然后运行：
``` bash
chkconfig --add apache
```

#### 4.6 系统管理- 进程管理-进程查看/终止进程
&emsp;进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占有一定的系统资源。

进程管理的作用:
* 判断服务器健康状态
* 查看系统中所有进程
* 杀死进程

**命令：ps** 查看系统的进程
``` bash
方式：
    ps aux                #查看系统中所有进程，使用 BSD 操作系统格式
    ps -le                #查看系统中所有进程，使用 linux 标准命令格式
```
**输出解释**：
* USER：该进程是由哪个用户产生的；
* PID：进程的 ID 号
* %CPU：该进程占用 cpu 资源的百分比，占用越高，进程越耗费资源。
* %MEM：该进程占用武力内存的百分比，占用越高，进程越耗费资源。
* VSZ：该进程占用虚拟内存的大小，单位 KB
* RSS：该进程占用实际武力内存的大小单位 KB
* TTY：该进程是在哪个终端中运行的。其中 tty1-tty7 代表本地控制台终端，tty1-tty6 是本地
的字符界面终端，tty7 是图形终端。pts/0-255 代表虚拟终端。
* STAT：进程状态。常见的状态有：R 运行、S 睡眠、T 停止状态、S 包含子进程、+位于后台
* START：该进程的启动时间
* TIME：该进程占用 CPU 的运算时间，注意不是系统时间
* COMMAND：产生此进程的命令名

**命令：top** 查看系统健康状态
``` bash
方式：
  top [选项]
选项：
  -d 秒数     #指定 top 命令每隔几秒更新。默认 3 秒
  h 或?       #显示交互模式的帮助
  P           #以 CPU 使用率排序，默认就是此项
  M           #以内存使用率排序，默认就是此项
  N           #以 PID 排序
  q           #退出 TOP
```
使用 TOP 的头 5 行信息：略 <br>
注：zombie 僵尸进程（这个进程正在终止，但还没有完成终止过程） <br>

**命令：pstree** 查看进程树
``` bash
方式：
  pstree [选项]
选项：
  -p                 #显示进程的 PID
  -u                 #显示进程的所属用户
```

**命令：kill** 终止进程
``` bash
方式：
     kill -l               查看可用的进程信号
     kill -1 22354         重启22354进程
选项：
```
信号代号 | 信号名称 | 说明
- | - | -
1  |  SIGHUP  | 该信号让进程立即关闭，然后重新读取配置文件重启
2  |  SIGINT  | 程序终止信号，终止前台进程
9  |  SIGKILL | 强制终止进程
14 |  SIGALRM | 时钟定时信号
15 |  SIGTERM | 正常结束信号（默认）
18 |  SIGCONT | 该金浩可以让暂停进程恢复执行，不能被打断
19 |  SIGSTOP | 该信号可以暂停前台进程，

**命令：killall**  按照进程名杀死进程
``` bash
方式：
  killall [选项][信号] 进程名
  killall -9 httpd      #杀死所有apache进程
选项：
  -i             #交互式，询问是否要杀死某个进程
  -I            #忽略进程名的大小写
```

**命令：pkill**  按照进程名终止进程（常用于根据端口号踢出用户）
``` bash
选项：
  -t 终端号 按照终端号踢出用户
```

#### 4.7 Linux系统管理-工作管理
把进程放入后台：
* 1）在命令后面加&符号
* 2）ctrl+z 快捷键，把命令放入后台并暂停

**命令：jobs** 查看后台进程
``` bash
选项：
  -l           #显示工作的PID
```
注：+号代表最近一个放入后台的工作，也是工作恢复时，默认恢复的工作。-号代表倒数第二个放入后台的工作。
二个放入后台的工作。<br>

**命令：fg**    将后台暂停的工作恢复到前台进行
``` bash
方式；
     fg  %工作号               恢复指定工作号的进程（和 PID 不一样）%可以省略
```

**命令：bg**    把后台暂停的工作恢复到后台执行
``` bash
方式：
  bg  %工作号                #（%可以省略）
```
注：后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行。<br>

**命令：fg**        将后台暂停的工作恢复到前台进行
``` bash
方式；
  fg  %工作号    #恢复指定工作号的进程（和 PID 不一样）%可以省略
```

#### 4.8 Linux系统管理-系统资源查看（linux相关信息）
**命令：vwstat**            监控系统资源
``` bash
方式：
  vmstat 刷新延时 刷新次数
选项：
  vmstat 1 3               #监听 3 次，每次隔一秒刷新
```

**命令：dmesg**             开机时内核检测信息（信息太多，需要管道付查找）
``` bash
方式：
  dmesg | grep CPU             #检测 CPU 启动信息（自检信息）
  cat /proc/cpuinfo            #查看 CPU 信息
```

**命令：free**            查看内存使用状态
``` bash
方式：
      free [-b|-k|-m|-g]
选项：
  -b               #以字节为单位显示
  -k               #以 KB 为单位显示，默认就是以 KB 显示
  -m              #以 MB 为单位显示
  -g              # 以 GB 为单位显示
```
缓冲和缓冲的区别：简单来说缓存（cache）是用来加速数据从硬盘中“读取”的，而缓冲（buffer）是用来加速数据“写入”硬盘的。<br>

**命令：uptime**      显示系统启动时间和平均负载（和 top,w 命令类似）

**命令：uname**        查看系统与内核相关信息
``` bash
选项：
  -a 查看系统所有相关信息
  -r 查看内核版本
  -s 查看内核名称
```

**判断当前系统位数**（用 file 查看系统外部命令）
``` bash
file /bin/ls                
```

**查看当前linux系统的发行版本**
``` bash
lsb_release -a              查看当前linux系统的发行版本
```

**命令：lsof**               列出进程打开或使用的文件信息
``` bash
方式：
  lsof [选项]
选项：
  -c 字符串                #只列出以字符串开头的进程打开的文件
  -u 用户名                #只列出某个用户的进程打开的文件
  -p pid                   #只列出某个 PID 进程打开的文件
```

#### 4.9 Linux系统管理-系统定时任务
**crond 服务管理与访问控制**
``` bash
sercice crond restart             #启动 crond 服务（默认开机启动）
chkconfig crond on
```

**命令：crond**             用户的 crontab 设置
``` bash
选项：
  -e                   #编辑 crontab 定时任务
  -l                   #查询 crontab 任务
  -r                   #删除当前用户所有的 crontab 任务
```
编辑格式：* * * * * 执行的任务 <br>
* 第一个“*”         第几分钟 0-59
* 第二个“*”         第几个小时 0-23
* 第三个“*”         第几天 1-31
* 第四个“*”         第几个月 1-12
* 第五个“*”         星期几 0-7

例子：
* 0 17 * * 1 命令             每周 1 下午 5 点执行命令
* 0 0 1,15 * 1 命令           每月 1 号或 15 号，每周一都会执行命令
* */10 4 * * *                每天 4 点，每隔 10 分钟执行一次

#### 4.10 日志管理
##### 4.10.1 日志管理简介
&emsp;在 CentOS 6.x 中日志服务已经有 rsyslogd 取代了原先的 syslogd 服务。rsyslogd 日志服务更加先进，功能更多。但是不论该服务的使用还是日志文件的格式其实都是和syslogd 服务相兼容的，所以学习起来基本和 syslogd 服务一致。

**确定服务启动**
``` bash
ps aux | grep rsyslogd                       #查看是否启动
chkconfig --list | grep rsyslog              #查看是否自启动
```
**常见日志的作用**
``` bash
/var/log/cron             #记录了系统定时任务相关的日志
/var/log/cups/            #记录打印信息的日志
/var/log/dmesg            #记录了系统在开机时内核自检的信息。
/var/log/btmp             #记录错误登陆的日志。这个文件是二进制文件，不能直接 iv 查看，而是要使用 lastb 命令查看：lastb
/var/log/lastlog          #记录系统中所有用户最后一次登录时间的日志，这个文件也是二进制文件，要使用 lastlog 命令查看。
/var/log/maillog          #记录邮件信息
/var/log/message          #记录系统重要信息的日志。这个日志文件中会记录 Linux 系统的绝大多多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件。
/var/log/secure           #记录验证后授权方面的信息，只要涉及账户和密码的程序都会记录。比如说系统的登陆，ssh 的登陆，su 切换用户，sudo 授权，甚至添加用户和修改用户密码都会记录在这个日志文件中。
/var/log/wtmp             #永久记录所有用户的登陆、注销信息，同时记录系统的启动、重启、关机时间。同样这个文件也是一个二进制文件，不能直接 vi，而需要使用 last 命令来查看。
/var/run/utmp             #记录当前已经登陆的用户的信息。这个文件会随着用户的登陆和注销而不断变化，只记录当前登陆用户的信息。同样这个文件不能直接 vi，而要使用 w，who，uersr等命令来查询
```

&emsp;除了系统默认的日志之外，采用 RPM 方法安装的系统服务也会默认把日志记在/var/log/目录中（源码包安装的服务日志是在源码包指定目录中）。不过这些日志不是用 rsyslogd 服务来记录和管理的，而是各个服务使用自己的日志管理文档来记录自身的日志。常见的有：
* /var/log/httpd/                #apache 服务默认目录
* /var/log/mail/                 #rpm 包安装的邮件服务的额外日志目录
* /var/log/samba/                #samba 服务的日志目录
* /var/log/sssd/                 #守护进程安全服务目录

##### 4.10.2 日志管理-rsyslogd服务
**1）基本日志格式包含以下四列**：
* 事件产生的时间；
* 发生事件的服务器的主机名；
* 产生事件的服务名或程序名；
* 事件的具体信息；
**2）/etc/rsyslog.com 配置文件**
``` text
authpriv.*                       /var/log/secure
```
#服务名称[连接符号]日志等级         日志记录位置<br>

服务名称：
* authpriv             安全和认证相关消息（私有的）
* cron                 系统定时任务 cron 和 at 产生的日志
* daemon               和各个守护进程相关的日志
* ftp                  ftp守护进程产生的日志
* kern                 内核产生的日志（不是用户进程产生的）
* local0-local7        为本地使用预留的服务
* lpr                  打印产生的日志
* mail                 邮件收发信息
* news                 与新闻服务器相关的日志
* syslog               有syslogd 服务产生的日志信息
* user                 用户等级类别的日志信息
* uucp                 uucp子系统的日志信息

链接符号:
* “*”代表所有日志等级，比如：“authpriv.*”代表 authpriv 认证信息服务产生的日志，所有的日志等级都要记录。
* “.”代表只要比后面的等级高的（包含该等级）日志都记录下来。比如： “cron.info”代表 cron 服务产生的日志，只要日志等级大于等于 info 级别，就记录。
* “.=”代表只记录所需等级的日志，其他等级的都不记录。比如：“*.=emerg”代表人和日志服务产生的日志，只要等级是 emerg 等级就记录。这种用法极少见，了解就好。
* “.!”代表不等于，也就是除了该等级的日志之外。其他低等级的日志都记录。

日志等级（从低到高）:
* debug                    一般的调试信息说明
* info                     基本的通知信息
* notice                   普通信息，但是有一定的重要性
* warning                  警告信息，但是还不会影响服务或系统的运行
* err                      错误信息，一般达到 err 等级的信息以及可以影响到服务或系统的运行了
* crit                     临界状况 i 型奶昔，比 err 等级还要严重
* alert                    警告状态信息，比 crit 还要严重。必须立即采取行动
* emerg                    疼痛等级信息，系统已经无法使用了

日志的记录位置：
* 日志文件的绝对路径，如“/var/log/secure”
* 系统设备文件，如“/dev/lp0”
* 转发给远程主机，如“@192.168.0.210:514”
* 用户名，如“root”
* 忽略或丢弃日志，如“~”

##### 4.10.3 日志管理-日志轮替
&emsp;当服务访问比较频繁的时候，比如游戏和网站，通常几百万的 pv，保存日志会很耗费资源，一般采用切割（按照时间将日志分开保存）或者轮替（只保留最近部分日志）。<br>
**1）日志文件的命名规则**
* 如果配置文件中拥有“dateext”参数，那么日志会用日期来作为日志文件的后缀，例如“secure-20130605”，这样的话日志文件名不会重叠，所以也就不需要日志文件的改名，只需要保存指定的日志个数，删除多余的日志文件即可。
* 如果配置文件中没有“dateext”参数，那么日志文件就需要进改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志，用来保存新的日志。当第二次进行日志轮替时，“secure.1”会自动改为“secure.2”，当前的“secure”会自动改为“secure1”，然后也会新建“secure”日志，用来保存新的日志，以此类推。

**2）logrotate 配置文件 etc/logrotate.conf**
* daily                     日志的轮替周期是每天
* weekly                    日志的轮替周期是每周
* monthly                   日志的轮替周期是每月
* rotate 数字                保留的日志文件的个数。0 指没有备份
* compress                  日志轮替时，旧的日志进行压缩
* create mode owner group   建立新日志，同时指定新日志的权限与所有者和所属组。如：create 0600 root utmp
* mail address              当日志了难题时，输出内容通过邮件发送到指定的邮件地址。如 mail shenc@lamp.net
* missingok                 如果日志不存在，则忽略该日志的警告信息
* notifempty                如果日志文空文件，则不进行日志轮替
* mimsize 大小              日志轮替的最小值。也就是日志一定要达到这个歌最小值才会轮替，否则就算时间达到也不轮替。
* size 大小                 日志只有大于指定大小才进行日志轮替，而不是按照时间轮替。如 size 100k
* dataext                    使用日期作为日志轮替文件的后缀。

例如把 apache 日志加入轮替：
``` bash
/usr/local/apache2/logs/access_log {
    daily
    create
    rotate 30
}
```

**命令：logrotate**
``` bash
方式：
  logrotate [选项] 配置文件名
选项：
  无              #无选项，则会按照配置文件中的条件进行日志轮替
  -v              #显示日志轮替的过程。加了-v 选项，会显示日志的轮替过程
  -f              #强制进行日志轮替。不管日志轮替的条件是否已经符合，强制配置文件中所有的日志进行轮替
```
#### 4.11 启动管理- 启动流程- 运行级别
``` bash
init 0          #关机
init 6          #重启
```
##### 4.11.1 系统默认运行级别
在/etc/inittab 文件下：
``` text
id:3:initdefault               #系统开机后直接进入哪个运行级别
```
注：以前的启动任务都是放在这个配置文件中的，但是现在版本分开了任务，这个文件只有runlevel设置，其它任务在注释里有说明，比如：/etc/init/rcS.conf 系统初始化

##### 4.11.2 启动过程
![Figure 2](picture/linux_Figure2.PNG)
**1）initramfs 内存文件系统**
emsp;CentOS 6.x 中使用 initramfs 内存文件系统取代了 CentOS 5.x 中的 initrd RAM Disk。他们的作用类似，可以通过启动引导程序加载到内存中，然后加载启动过程中所需要的内核模块，比如 USB、SATA、SCSI 硬盘的驱动和 LVM、RAID 文件系统的驱动。<br>
可以查看/boot/下的 initramfs 文件:
``` bash
mkdir /tmp/initramfs
cp /boot/initramfs-2.6.32-279.e16.i686.img /tmp/initramfs/
cd /tmp/initramfs/
file initramfs-2.6.32.279.e16.i686.img
mv initramfs-2.6.32.279.e16.i686.img initramfs-2.6.32.279.e16.i686.img.gz
gunzip initramfs-2.6.32.279.e16.i686.img.gz
file initramfs-2.6.32.279.e16.i686.img
cpio -ivcdu < initramfs-2.6.32.279.e16.i686.img
```
可以看到这个文件解压缩后和 linux 的根目录类似。<br>

**2）调用/etc/init/rcS.conf 配置文件**
主要功能有两个：
* 先调用/etc/rc.d/rc.sysint，然后由/etc/rc.d/rc.sysint 配置文件进行 Linux 系统初始化。
* 然后再调用/etc/inittab，然后由/etc/inittab 配置文件确定系统的默认运行级别。

/etc/rc.d/rc.sysint 的主要作用：
* 获得网络环境
* 挂载设备
* 开机启动画面 Plymouth（取替了过往的 RHGB）
* 判断是否启用 SELinux
* 显示于开机过程中的欢迎画面
* 初始化硬件
* 用户自定义模块的加载
* 配置内核的参数
* 设置主机名
* 同步存储器
* 设备映射器及相关的初始化
* 初始化软件磁盘阵列（RAID）
* 初始化 LVM 的文件系统功能
* 检验磁盘文件系统（fsck）
* 设置磁盘配额（quota）
* 重新以可读写模式挂系统磁盘
* 更新 quota（非必要）
* 启动系统虚拟随机数生成器
* 配置机器（非必要）
* 清除开机过程当中的临时文件
* 创建 ICE 目录
* 启动交换分区（swap）
* 将开机信息写入/var/log/dmessage

**3)调用/etc/rc.d/rc 文件**
&emsp;运行级别参数传入/etc/rc.d/rc 这个脚本之后，由这个脚本文件按照不同的运行级别启动/etc/rc[0-6].d/目录中的相应的程序（这个目录下的程序全是软连接）<br>
* /etc/rc3.d/k??开头的文件（??是数字），会按照数字顺序依次关闭。
* /etc/rc3.d/S??开头的文件（??是数字），会按照数字顺序依次启动。

启动管理-启动引导程序-Grub 配置
1 grub 中分区表示:
``` text
硬盘                 分区               Linux 中设备文件名      Grub 中设备文件名
                  第一个主分区           /dev/sda1                  hd(0,0)
第一块            第二个主分区            /dev/sda2                  hd(0,1)
SCSI 硬盘         扩展分区               /dev/sda3                  hd(0,2)
                  第一个逻辑分区         /dev/sda5                  hd(0,3)

                  第一个主分区           /dev/sdb1                  hd(1,0)
第二块            第二个主分区            /dev/sdb2                  hd(1,1)
SCSI 硬盘         扩展分区               /dev/sdb3                  hd(1,2)
                  第一个逻辑分区          /dev/sdb5                  hd(1,3)
```
&emsp;grub 的配置文件在 /boot/grub/grub.conf。注：/etc/grub.conf 是软链接。 <br>
&emsp;分为两个部分，前面 4 行属于总体配置，后面每 4 行属于每个系统的配置，后面的优先级大于前面的整体配置。 <br>
整体配置：
``` text
default=0                                 #默认启动哪一个气筒
timeout=5                                 #等待 5s，选择哪一个系统
splashimage=(hd0,0)/grub/splash/xpm.gz    #背景图像保存位置，grub 目录下
hiddenmenu                                #启动界面影藏菜单
```

#### 4.12 备份与恢复-概述
##### 4.12.1 系统常见备份数据
* /root/目录
* /home/目录
* /var/spool/mail/目录
* /etc/目录
* 其他目录
##### 4.12.2 安装服务的数据
* apache 需要备份的数据：配置文件 网页主目录 日志文件
* mysql  需要备份的数据：/usr/local/mysql/data/ /var/lib/mysql/
##### 4.12.3 备份策略
* 完全备份：完全备份就是指把所有需要备份的数据全部备份，当然完全备份可以备份整款硬盘，整个分区或某个具体的目录。（空间需要大，备份时间长）
* 增量备份：第一次进行完全备份，每次只备份跟上一次相比新增的数据，重复的不备份。（恢复起来麻烦）
* 差异备份：第一次进行完全备份，每次只备份跟第一次相比新增的数据，重复的不备份。

##### 4.12.4 备份与恢复命令（自己写增量备份脚本太麻烦）
**命令：dump**  备份
``` bash
方式：
  dump [选项] 备份之后的文件名 原文件或目录
选项：
  -level                #就是我们说的 0-9 十个备份级别
  -f 文件名              #指定备份之后的文件名
  -u                    #备份成功之后，把备份时间记录在/etc/dumpdates 文件
  -v                    #显示备份过程中更多的输出信息
  -j                    #调用 bzlib 库压缩备份文件，骑士就是把备份文件压缩成为.bz2 格式
  -W                    #显示允许被 dump 的分区的备份等级及备份时间
```
例子：
``` bash
dump -0uj /root/boot.bak.bz2 /boot/     #备份命令。先执行一次完全备份，并压缩和更新备份时间
cat /etc/dumpdates                      #查看备份时间文件
cp install.log /boot/                   #复制日志文件到 boot 分区
dump -1uj -f /root/boot.bak1.bz2 /boot/ #增量备份/boot 分区，并压缩
dump -W                                 #查询分区的备份时间及备份级别的
```
注：完全备份目录，只能使用0级别进行完全备份，而不再支持增量备份（只在备份分区才行）

**命令：restore**  恢复
``` bash
方式：
  restore [模式选项] [选项]
  restore -C -f 备份的文件            #查看已备份的文件和原文件的区别
  restore -r -f 备份的文件            #恢复到当前目录
选项：
  -C                                 #比较备份数据和实际数据的变化
  -i                                 #进入交互模式，手工选择需要恢复的文件
  -t                                 #查看模式，用于查看备份文件中拥有哪些数据
  -r                                 #还原模式，用于数据还原

  -f                                 #指定备份文件的文件名（这个不是四个模式中的一个）
```
注：restore 命令常用的模式有以上四种，这四个模式不能混用。

## 二 Linux 附录
### 1. Linux 常用命令
### 1.1 常用文件处理命令
**ls**
``` bash
方式：
  ls [选项][参数]
常用选项:
  -a  #所有文件
  -l  #详细信息
  -i  #inote节点
  -h  #大小直观显示
  -d  #显示选择的目录本身，不显示子目录
```
文件信息7个部分：
* 第一个  文件权限    第一个字符（-:可执行文件 d:目录 l:软连接） 后面的字符就是3*3个管理权限（读、写、执行）
* 第二个  文件引用计数
* 第三个  用户所有者（只能有一个）
* 第四个  用户所有组（只能有一个）
* 第五个  文件的大小
* 第六个  文件的最后修改时间（没有创建时间的概念）
* 第七个  文件名

**mkdir**  （可以连续创建目录，空格分开）
``` bash
命令选项：
  -p     #递归创建目录（当目录不存在的时候）
```

**rmdir**  (删除目录，删除的是空目录，不能删除非空目录）

**cp**     (复制文件和目录）
``` bash
命令选项：
  -r     #递归复制整个目录
  -p     #保留文件属性（修改时间相同）
```

**mv**        (移动也叫做剪切）

**rm**        （删除，不可恢复，但是发行版有回收站）
``` bash
选项：
  -r            #删除整个目录
  -f            #强制删除
```

**touch**        （创建文件，用vi也可以创建但直接打开了）

**cat**          （查看文件内容）
``` bash
命令选项：
  -n            #显示行号
```
注: 如果命令 cat file.cc 写成 tac file.cc  那么将会倒叙显示文本

**more**       (分页显示，文件太长，帮助信息经常用到，要记住）

**less**       (分页显示，可以向上翻页，可以搜索，功能更强大）
注： /加字符串可以搜索，n浏览下一个搜索结果

**head**      （看文件的前几行，默认前10行）

**tail**      （看文件的后几行，默认后10行）
``` bash
选项：
  -f           #动态显示，文件出现变换会动态显示（比如查看/var/log/messages这种日志文件）
  -n           #指定行数
```

**切换目录操作** <br>
* 命令名称：   cd
* 目录名称：   pwd
* 当前目录：   .
* 上一级目录： ..

**ln**       （生成链接文件，默认是硬链接）
``` bash
选项：
  -s          #创建软连接（类似于快捷方式，拥有全部权限）
```
注：
* 软链接：  一个指向源文件的链接，很小只有10几个字节。软连接可以跨分区，可以针对目录。
* 硬连接：  同步更新（存储在同一个内存），改变一个会改变另一个文件，但删除不会同步。可以通过inote来查看是否是硬链接，不能链接到不同的分区，不能针对目录。

**chmod**     （文件权限管理，root和所有者都可以改变）
``` bash
选项：
  -R            #递归。给一个文件目录下的所有文件赋予相关权限
  u             #所有者
  g             #分组
  o             #其他
  a             #所有
  +-=
```
数字表示权（脚本常用）：
* r    4
* w    2
* x    1

注：针对目录 rwx 的解释是不一样的。r代表可以列出子目录内容，w代表可以在目录下修改（创建，删除），x代表可以进入目录。目录和文件的权限冲突，以目录的权限为主。


**chown**      （改变所有组和所有者，只有root可以改变）
``` bash
方式：
  chown users:group files
选项：
  -R      #递归，改变指定文件夹下的所有文件及目录
```

**chgrp**      （改变用户的所有组，同chown）

**umask**      (新建文件的缺省参数）
``` bash
选项：
  -S          #查看默认设置
  数字        #设置参数
```

### 1.2 文件搜索命令
&emsp;windows有个工具叫everything（搜索很快，但只针对于NTFS）<br>
**find**           （搜索文件，尽量减少搜索操作，太占资源）
``` bash
方式：
  find  [搜索范围] [匹配条件]  #匹配条件使用通配符和正则表达式不同。
  * 匹配任意个不同字符
  ？匹配任意单个字符
选项：
  find /etc -name init          #在/etc目录下搜索init（精准搜索）
  find /etc -name *init*        #通配符（模糊搜索）
  find /etc -iname *init*       #不区分大小写
  #注：linux中一个数据块512Bytes
  find /    -size +204800       #查找大于100M文件
  find /home -user username     #根据所有者查找
  find /home -group  groupname  #根据所有组查找

  find /etc -cmin  -5           #查找5分钟内被修改的文件和目录（文件属性）
  find /etc -amin               #访问时间access
  find /etc -mmin               #文件内容modify（修改）

  find /etc -size +163840 -a -size -204080  #同时满足两个条件
  find /etc -size +163840 -o -size -204080  #满足一个以上即可

  -type                  #根据文件类型进行查找。f文件  d目录   l软连接
  -inum                 #根据i节点查找（每个文件都有一个inote节点，可以用来查找硬链接）

  -exec                #使用命令。例如： find /etc -name inittab -exec ls -l {} \;  查找文件并显示详细信息。\表示转义, ;表示命令结束
  -ok                 #要手动确认是否执行命令
```

**locate**   （文件搜索，速度很快，但在/tmp这种临时文件目录下的文件是不会搜索的）
&emsp;原理：维护了一个资料库，在/var/lib/mlocate.db这个数据库里，可以想象得到，如果一个文件没有被收录到该数据库中，是差不到的。<br>
``` bash
方式:
  locate 文件名
  -i               #忽略大小写
```

**updatedb**  更新上述资料库（不更新，是查不到的）

**which**   (搜索命令所在目录及别名信息)
``` bash
方式：
  which 命令名
```

**whereis**  搜索命令所在位置和帮助文档（/usr/share/man/下）

**grep**   在文件中搜寻字符串匹配的行并输出
``` bash
方式：
  grep -iv [指定字符串] [文件]
选项：
  -i          #不区分大小写
  -v          #排除指定字符串（可以用来剔除注释行^#）
```

**man**   获得帮助信息，如果命令和配置文件同名，先查询命令
``` bash
方式：
  man [命令或配置文件]
例子：
  man ls         #查看ls的帮助信息
  man services   #查看配置文件services的帮助信息。用more就把整个文件显示出来了。
```

**info**  和man差不多
``` bash
方式：     
  info 命令或文件名
```

**help**  查看shell内置命令的帮助，内置命令如umask cd用man是查不到的。
``` bash
方式：
  help 命令
```

**whatis**   只查看简单介绍信息
``` bash
方式：
  whatis 命令或配置文件
```

**--help**  只查看选项信息
``` bash
方式：
  命令  --help
```

**useradd**      添加新用户
``` bash
方式：
  useradd username
```

**passwd**        设置或更改密码（管理员可以更改任何用户密码）
``` bash
方式：
  passwd username
```

**who**       查看用户 <br>
注：第一个表示登录的用户、第二个表示登录的终端（tty表示本地），第三个表示登录时间和（IP地址）

**w**       查看用户更多的信息（相比who）

**uptime**   查看服务器共运行了多长时间

### 1.3 压缩和解压文件
&emsp;一般来讲linux系统的压缩包拷贝到windows都是可以解压的，但windows里的压缩包解压到linux，就要看linux支不支持了（rar就不支持）<br>
* .zip  #windows和linux共用的
* .gz  

**gzip**      将文件或目录压缩成.gz格式（只能压缩文件，且不保留源文件）
``` bash
方式：
  gzip fileneme
```

**gunzip**    解压.gz文件

**tar**       打包（先打包再gzip压缩，后缀名为.tar.gz）
``` bash
方式：
  tar -cvf  压缩后文件名 源文件或目录   #（只打包）
  tar -zcvf 压缩后文件名 源文件或目录   #（打包并压缩）
  tar -zxvf 压缩                       # （解压）
选项：
  -c      #表示打包
  -v      #显示详细信息
  -f      #指定文件名
  -z      #解压缩，压缩
  -x      #解包
```
**zip**         压缩文件或目录（.zip），压缩比例不咋地
``` bash
方式：
  zip [选项]  [压缩后文件名]  [文件或目录]
选项：
  -r  压缩目录
```

**unzip**        解压zip文件

**bzip2**        压缩文件（.bz2）,压缩比率大，能保留源文件
``` bash
方式：
  bzip2 选项 [-k] [文件]
  bzip2 -k filename                  #生成.ba2的压缩包
  tar   -cjf  file.tar.bz2  file    #生成.tar.bz2的压缩包
选项：
  -k                                 #产生压缩文件后保留原文件
```

**bunzip2**    解压缩
``` bash
方式：
  bunzip2 -k     file.bz2
  tar     -xjf  file.tar.bz2
选项：
  -k                      #解压后保留原文件
```
### 1.4 网路命令
**write**         给在线用户发信息
``` bash
方式：
  write myuser     #向myuser发送信息
```
注：编辑信息过程中，delete删除，Ctrl+D结束并保存 <br>

**wall**        给所有用户发送广播信息
```
方式：
  wall message
```

**ping**         测试网络连通性
``` bash
方式：
  ping 选项  IP地址
选项
  -c                  #指定发送次数
```

**ifconfig**   查看和设置（root执行）网卡信息
``` bash
方式：
  ifconfig  网卡名称  IP地址
```

**mail**        查看发送电子邮件
``` bash
方式：
   mail 用户名    #给用户发送邮件
   mail           #查看邮件
```

**last**       查看用户历史登录信息

**lastlog**   所有用户最后一次登录的信息
``` bash
方式：
  lastlog          #所有用户最后一次登录
  lastlog -u uID   #检查特定用户上次登录的时间
```

**traceroute**      显示数据包到主机间的路径
``` bash
方式：
  traceroute   www.sina.com.cn    #查看www.sina.com.cn到本机的路线
```

**netstat**  显示网络相关信息（非常重要）
``` bash
方式：
  netstat  [选项]
  netstat  -tlun      #查看本机的端口，监听的端口（TCP），非监听
  netstat  -an        #查看本机所有的网络连接（服务状态和网络程序）
  netstat  -rn        #查看本机路由表（比如网关,ifconfig是查不到的）
选项：
  -t           #TCP协议（安全可靠，握手原则）
  -u           #UDP协议
  -l           #监听
  -r           #路由
  -n           #显示IP地址和端口号
```

**setup**   redHat开发的管理工具集合（其它版本不存在）<br>
选项：
* 防火墙配置
* 网络设置
* 系统服务    （服务启动）
* 验证配置
配置完保存并退出。重启网络服务 servies network restart。该方法配置网络是永久生效的,和ifconfig不一样。<br>


**mount**             挂载命令（手动挂载）
``` bash
方式：
  mount [-t 文件系统] 设备文件名 挂载点
```
例：光盘文件系统：iso9660    设备文件名： .dev/cdrom  <br>

**umount**     卸载命令（必须手动卸载）
``` bash
方式：
  umount /dev/sr0            #卸载光驱
```
### 1.5 关机和重启命令
**shutdown**        关机或重启命令（建议使用）
``` bash
方式：
  shutdown [选项] 时间
  shutdown -h now
  shutdown -r 20:30     #晚上8点半重启
选项：
  -c               #取消前一个关机命令
  -h               #关机
  -r               #重启
```
注：其它关机/重启命令：
* halt      #关机
* poweroff  #关机
* init 0    #关机
* reboot    #重启
* init 6    #重启

init 后面的数字代表什么意思？系统运行级别。使用cat /etc/inittab可以查询init的配置文件，不要把默认设置成0或者6 ：
* 0 关机
* 1 单用户                    启动最小服务（修复使用），相当于安全模式
* 2 不完全多用户，不含NFS服务  NFS（网络文件系统，文件共享）
* 3 完全多用户
* 4 未分配
* 5 图像界面
* 6 重启

**runlevel**        查询系统运行级别
上一个运行级别 当前运行级别。<br>

**logout**        退出登陆命令（结束管理后，退出，以免被串改）

### 1.6《vim》文本文件编辑器
&emsp;vim是一个功能强大的全屏幕文本编辑器，是linu/UNIX上最常用的文本编辑器，塔的作用是建立、编辑、显示文本文件。<br>
**命令**
* i|a|o       #进入编辑模式,a（光标所在字符后插入）A（在光标所在行尾插入）i（光标所在前插入）I（在光标所在行行首插入）o在（光标下插入新行）O（在光标上插入新行）
* :wq         #保存并退出，w表示写入，q表示退出
* :set nu     #给文件加上行号
* :set nonu   #取消行号
* :n          #到第n行
* gg          #到第一行
* G           #到最后一行
* $           #移至行尾
* 0           #移至行首

**删除**
* x           #删除光标所在处字符
* nx          #删除光标所在处n个字符
* dd          #删除光标所在行，
* ndd         #删除光标以下n行
* dG          #删除光标所在行到文件末尾的内容
* D           #删除光标所在处到行尾内容
* :n1,n2d     #删除指定范围的行

**复制和剪切**
* yy     #复制当前行
* nyy    #复制当前行以下n行
* dd     #剪切当前行
* ndd    #剪切当前行以下n行
* p、P   #粘贴在当前光标所在行下或行上

**替换或取消命令**
* r    #取代光标所在处字符
* R    #从光标所在处开始替换字符，按Esc结束
* u    #取消上一步操作

**搜索和搜索替换命令**
* /string            #搜索指定字符串
* :set ic            #搜索时忽略大小写
* n                  #搜索字符串是，指定下一个出现位置
* :%s/old/new/g      #全文替换指定字符串，%s表示全文替换，g表示替换不询问，如果是c表示要询问。
* :n1,n2s/old/new/g  #在一定范围内替换指定字符串，n1,n2分别表示起始行和结束行。

**保存和退出命令**
* :w                #保存修改
* : new_filename     #另存为指定文件
* :wq               #保存修改并退出
* ZZ                #快捷键，保存修改并退出
* :q!               #不保存修改退出
* :wq!              #保存修改并退出（文件所有者及root用户可使用）

**vim的使用技巧**
&emsp;定义的快捷键在重启的时候回消失，需要在各个用户的家目录下配置.vimrc文件，该文件设置命令，可以永久保存（命令前面不需要加:）。<br>
导入文件内容:
* :r 文件名     #在光标处导入指定文件的内容
* :r !命令      #可以在不离开vim的情况下执行命令

* :r !date      #可以将当前日期插入到光标所在处

**定义快捷键**   :map 快捷键  触发命令
``` text
方式：
  :map ^P I#<ESC>       #给光标所在行添加注释。^P是ctrl+p（需同时按），I行首插入#并退出编辑模式
  :map ^B 0x            #取消当前行注释。0移动到行首，x删除单钱字符
  :map ^M imymail@qq.com<ESC>   #插入我的邮箱
```

**连续行注释**
``` text
方式：
  :n1,n2s/^/#/g      #^表示行首，
  :n1,n2s/^#//g      #取消行首的注释
  :n1,n2s/^/\/\//g   #两个\表示转义，给c或者c++文件添加注释
```
**替换**
* :ab mymail  samlee@lampbrother.net

## 三 linux-Shell使用
### 1. Shell基础
&emsp;Bourne Shell。1979年1起Unix就开始使用Bourne Shell,主文件名为sh。家族有sh ksh Bash psh zsh
C Shell。主要在BSD版的Unix系统中使用，其语法和c语言相类似而得名。家族主要有csh tcsh。shell配置文件路径：/etc/shells <br>

#### 1.1 多命令执行符
``` text
多命令执行符    格式            作用  
;            命令1;命令2      多个命令顺序执行，命令之间无联系
                             不管哪个命令错误，也不会影响其它命令

&&           命令1&&命令2     逻辑与
                             当命令1正确执行，命令2才会执行
                             当命令1执行错误，命令2不会执行

||           命令1||命令2     逻辑或
                             当命令1执行错误，命令2才会执行
                             当命令1执行正确，明老公呢2不会执行
```
例:创造一个100M文件需要多长时间<br>
``` bash
date;dd if=/dev/zero of=/root/testfile bs=1k count=100000;date
```

**管道符**：
``` text
|            命令1|命令2      命令1的正确输出作为命令2的操作对象
```
例：<br>
``` bash
ls -a /etc/ | more                  #分屏显示结果
netstat -an | grep "ESTABLISHED"    #查看有多少用户连接本服务器
```

**shell的控制字符**
``` text
控制字符               作用
\\                    输出\本身
\a                    输出警告
\b                    退格键，也就是向左删除键
\c                    取消输出行末的换行符
\e                    ESCAPE键
\f                    换页符
\n                    换行符
\r                    回车键
\t                    制表符，也就是TAB键
\v                    垂直制表符
\0nnn                 按照八进制ASCLL码表输出字符。其中0为数字零，nnn是三维八进制数
\xhh                  按照16进制ASCLL码表输出字符。其中hh是两位十六进制数。

\e[1;                 开启颜色输出
\e[0m                 结束颜色输出
```
例： echo -e "\e[1;31m hello \e[0m"       #输出hello并以红色显示<br>
颜色表：
``` text
30m=黑色  31m=红色    32m=绿色  33m=黄色
34m=蓝色  35m=洋红    36m=青色  37m=白色
```

#### 1.2 Shell基础-shell脚本运行方式
脚本运行方式：
* ./hello.sh               #当前目录下，相对路径
* bash hello.sh
* /home/taochao/.sh        #绝对路径
注：有个俄罗斯方块的例子，Tetris.sh，可以下载下来看看。<br>

windows脚本和linxu下shell**脚本的转换**
* dos2unix       windows下编辑的脚本转为linux
* unix2dos       linux下脚本转换为windows

#### 1.3 Shell基础-Bash基本功能-历史命令与补全
**history**              历史命令
``` bash
方式：
  histort [选项]  历史命令保存文件
选项：
  -c          #清空历史命令
  -w          #把缓存中的历史命令写入历史命令保存文件.basr_history（默认是每次关机登出用户的时候写入文件的）。历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改。
```

**历史命令的调用**
* 使用上下箭头调用以前的历史命令
* 使用"!n"重复执行第n条历史命令
* 使用"!!"重复执行上一条命令
* 使用"!字串"重复执行最后一条以该字符串开头的命令

#### 1.4 Shell基础-Bash基本功能-命令的别名与快捷键
**alias**   给命令设置别名，但是暂时的
``` bash
方式：
  alias                           #查询命令别名
  alias 别名='原命令'              #给一个命令赋予一个别名
  alias vi='vim'                  #有颜色的vi命令
  alias ll='ls -l --color=auto'   #有颜色的ls
  alias ls='ls --color=auto'
```

**unalias**  删除别名
``` bash
方式：
  unalias 别名
```

**命令的执行顺序**：
* 第一顺位执行用绝对路径或相对路径执行的命令
* 第二顺位执行别名
* 第三顺位执行Bash的内部命令
* 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令
永久生效：<br>
别名要永久生效，需要在 /root/.bashrc中声明 <br>

**Bash常用快捷键**
* ctrl+E      #把光标移动到命令行结尾
* ctrl+C      #强制终止当前命令
* ctrl+L      #清屏，相当于clear命令
* ctrl+U      #删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退格键一个个删除。
* ctrl+Y      #粘贴ctrl+U或ctrl+K剪切的内容
* ctrl+R      #在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面
* ctrl+D      #退出当前终端
* ctrl+A      #把光标移动到命令开头。如果我们输过的命令过长，想要把光标移动到命令行开头时使用。
* ctrl+Z      #暂停，并放入后台。占太多系统资源
* ctrl+k      #删除或剪切光标之后的内容。
* ctrl+S      #暂停屏幕输出
* ctrl+Q      #恢复屏幕输出


#### 1.4 Shell基础-Bash基本功能-输入输出重定向
**1）标准输入输出**
``` text
设备        设备文件名       文件描述符      类型
键盘        /dev/stdin        0            标准输入
显示器      /dev/stdout       1            标准输出（一般是默认）
显示器      /dev/stderr       2            标准错误输出
```
**2）输出重定向**
使用场景：需要在服务器低峰期执行高负载命令，把结果保存在文件中。<br>
``` text
类型                   符号             作用
标准输出重定向        命令>文件         以覆盖的方式，把命令正确输出输出到指定文件或设备当中
                     命令>>文件        以追加的方式，把命令的正确输出输出到指定的文件或设备当中
标准错误输出重定向    命令2>文件         以覆盖的方式，把命令的错误输出。。。。
                     命令2>>文件       以追加的方式，把命令的错误输出。。。。
```
注：上面的方法实际工作中用不到，因为命令格式不一样，无法在运行前判断是正确输出还是错误输出。实际工作中更多的是：

``` text
                        命令>文件 2>&1         以覆盖方式保存在同一个文件中
                        命令>>文件 2>&1        以追加方式保存在同一个文件中
正确输出和错误同时保存    命令 &>文件            以覆盖方式保存在同一个文件中     
                        命令 &>>文件           以追加方式保存在同一个文件中
                        命令>>文件1 2>>文件2   正确输出到文件1，错误输出到文件2
```
命令 &>dev/null  把输出丢掉垃圾箱，不保存

**3）输入重定向**
**wc**      统计
``` bash
方式：
  wc [选项] [文件名]
选项：
  -c      #统计字节数
  -w      #统计单词数
  -l      #统计行数
```
输入重定向：<br>
* 命令 < 文件      #将文件作为命令的输入

#### 1.5 通配符（一般只是用来匹配文件名）
``` text
符号           正则表达式                        通配符
?      限定符，匹配前面0次或一次               匹配一个任意字符
       跟在其它限定符后面时，非贪婪匹配
*      限定符，匹配任意次                      匹配0或任意内容
[]                                            匹配括号中任意一个字符
[-]                                           范围匹配
[^]    定位符；逻辑非（中括号中）               逻辑非
```
常用结合通配符的命令：ls rm mkdir cp

#### 1.6 shell特殊符号
``` text
符号         作用
''           单引号。单引号中所有特殊符号均无作用
""           双引号。双引号里"$"，"`"，"\"这些特殊符号有意义
``           反引号。和$()一样，把系统命令括起来
$()          和反引号一样，引用系统命令，先执行命令。
#            在shell脚本中，代表注释
\            转义符，很常用。
```

### 2. Shell基础-Bash变量
#### 2.1 用户自定义变量
**变量规则**
* 变量名称可以由字母、下划线和数字组成，但是不能以数字开头。
* 在Bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必修指定变量类型为数值型。
* 变量用等号连接值，等号左右两侧不能有空格
* 变量的值如果有空格，需要使用单引号或双引号包括
* 在变量的值中，可以使用转义符
* 如果需要增加变量的值，那么可以进行变量值的叠加。不给过变量需要用双引号包含"$变量名"或用${变量名}包含。
* 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。
* 环境变量名建议大写，便于区分。
**变量分类**
* 用户自定义变量
* 环境变量：这种变量中主要保存的是和系统操作环境相关的数据。
* 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。
* 预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。

**set**      变量查看（环境变量，自定义变量）

**unset**    变量删除

#### 2.2 -环境变量
**环境变量是什么？**<br>
&emsp;用户自定义变量只在当前的Shell中生效，而环境变量会在当前Shell和这个Shell的所有子Shell当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的Shell中生效。<br>
**环境变量操作**:
``` text
export 变量名=变量值      #申明变量
env                      #查询环境变量
set                      #查询所有变量
unset 变量名              #删除变量
pstree                   #进程树
```
**重点讲两个变量**:
* 1）PATH。系统查找命令的路径。bin文件夹添加方法：PATH="$PATH":/root/sh  （临时生效）
* 2）PS1。定义系统提示符变量，不是环境变量。（就是终端前面那一串字符串）

#### 2.3 位置参数变量
``` text
位置参数变量      作用
$n               n为数字，$0代表命令本身，十以上的命令要用括号${10}
$*               这个变量代表命令行中的所有参数，相当于一个字串
$@               这个变量也代表命令行中的所有参数，不过$@区分对待每个参数
#$               这个变量代表命令行中所有参数的个数
```

#### 2.4 预定义变量
**1）预定义变量**
``` text
预定义变量         作用
$?                最后一次执行的命令的状态。0为正确执行，非0不正确
$$                当前进程的PID号
$!                后台运行的最后一个进程的进程号
```
注：其实逻辑与或也是这个原理才能工作的
**2）接受键盘的输入**
**read**
``` bash
方式：
  read [选项] [变量名]
选项：
  -p "提示信息"      #在等待read输入时，输出提示信息
  -t 秒数            #read命令会一直等待用户输入，使用此选项可以指定等待时间
  -n 字符数          #read命令只接受指定的字符数，就会执行
  -s                 #隐藏输入的数据，适用于机密信息的输入
```

### 3. 数字运算与运算符
#### 3.1 基本运算
``` text
aa=11
bb=22
cc=$aa+$bb                 #11+22（字符串类型）
declare -i c=$aa+$bb       #33（整数类型）
dd=$(exper $aa + $bb)      #33（exper相当于是一个命令）
ee=$(let $aa + $bb)    
```

#### 3.2 declare
##### 3.2.1 declare
``` bash
方式：
  declare [+/-] [选项] [变量名]
选项：
  -                  #给变量名设定类型属性
  +                  #取消变量的属性
  -i                 #将变量声明为整数型
  -x                 #将变量声明为环境变量
  -p                 #显示指定变量的被声明的类型
```
**推荐用法**： <br>
$((运算式)) 或 $[运算式] <br>
例如： <br>
``` bash
ff=$(( $aa+$bb ))
gg=$[ $aa+$bb ]
```

**运算符的优先级**：括号 逻辑非 乘除  加减 比较运算符  逻辑与或 <br>

##### 3.2.2  变量测试与内容替换
不推荐常用
``` text
变量置换方式     y没有设置   y为空值     变量y设置值
x=${y-新值}      x=新值      x为空        x=$y
x=${y:-新值}     x=新值     x=新值        x=$y   
```

### 4. Shell基础-环境变量配置文件

**source**     强制配置文件生效（避免重启过程）
``` bash
方式：
    source 配置文件
    . 配置文件
```
**环境变量配置文件简介**<br>
&emsp;环境变量配置文件中主要是定义对系统的操作环境生效的默认环境变量，比如PATH、HISTSIZE（历史命令保存条数）、PSI（提示符）、HOSTNAME（主机名）等默认环境变量。<br>

**系统主要环境变量配置文件**<br>
输入用户名密码后：<br>
* /etc/profile              #所有用户生效
* /etc/profile.d/*.sh       #所有用户生效
* ~/.bash_profile           #当前用户生效
* ~/.bashrc                 #当前用户生效
* /etc/bashrc               #所有用户生效

#### 4.1 环境变量配置文件-作用
**/etc/profile的作用**：
* USER变量
* LOGNAME变量
* MAIL变量
* PATH变量
* HOSTNAME变量
* HISTSIZE变量
* umask
* 调用/etc/profile.d/*.sh文件

**~/.bashrc文件的作用**：中文提示符、umask（非登录环境配置）、PATH

#### 4.2 Shell基础-环境变量配置文件-其它配置文件和登录信息
* 1）注销时生效的环境变量配置文件
  * ~/.bash_logout
* 2）其它配置文件
  * ~/bash_history
* 3）本地终端欢迎信息
  * /etc/issue
* 4）远程登录欢迎信息
  * etc/issue.net  
  * 注：需要在ssh的配置文件/etc/ssh/sshd_config决定是否显示
* 5）登录后欢迎信息
  * /etc/motd
  * 注：不管本地登录，还是远程登录，都可以显示此欢迎信息

### 5. shell编程-正则表达式
**1）正则表达式与通配符**
&emsp;正则表达式用来在文件中匹配符合条件的字符串，正则式包含匹配。grep，awk，sed等命令可以支持正则表达式。
通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配了。<br>
``` bash
grep "^&" test.txt     #匹配空白行
```
注：grep是提取行，cut是提取列

#### 5.1 字符截取命令-cut命令
**cut**           提取文本的列
``` bash
方式：
  cut [选项] 文件名
  cut -f 2,3 文件名        #提取文件中的第2,3个字段的列
  cut -d ":" -f 1 文件名   #指定:为字段分割符
选项：
  -f 列号          #提取第几列
  -d 分割符        #按照指定分割符分割列
```
例：我们准备这样的文档（单词之间必须是制表符，不能是空格，当然也可以指定其他分割符）<br>
``` texr
ID    Name    gender   Mark
1     Liming  M        86
2     Sc      M        90
3     Gao     M        83
```
**批量删除普通用户**:
``` bash
ueserlist=cat /etc/passwd | grep /bin/bash | grep -v root | cut -d ":" -f 1
```
cut的局限。如果是空格符作为分隔符，必须只有一个分割符的时候才有效。<br>

#### 5.2 字符截取命令-printf命令
&emsp;严格来讲，printf不是字符截取命令，只是常用的格式化输出命令。printf也不能跟在管道符后面。<br>
``` bash
方式：
  printf '输出类型输出格式'  输出内容
```
输出类型：<br>
* %ns           #输出字符串。n是数字表示输出几个字符
* %ni           #输出整数。n是数字指代输出几个数字
* %m.nf         #输出浮点数。m,n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数。其中2位是小数，6位是整数。

输出格式：<br>
* \a           #输出警告声
* \b           #输出退格键
* \f           #清除屏幕
* \n           #换行
* \r           #回车，也就是Enter键
* \t           #水平输出退格键，也就是Tab键
* \v           #垂直输出退格键，也就是Tab键

**例**：
``` bash
printf %s 1 2 3 4 5 6
printf %s %s %s 1 2 3 4 5 6
printf '%s' $(cat student.txt)      #打印student.txt文件
```

注：在awk命令的输出中支持print和printf命令 <br>
* print：print会在每个输出之后自动加入一个换行符（Linux默认没有print命令）
* printf：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符。

#### 5.3 字符截取命令-awk命令
&emsp;awk功能更多，但是使用复杂。我们一般把它称为awk编程。（注：支持管道符）<br>
``` bash
awk '条件1{动作1}条件2{动作2}...' 文件名
```
条件（Pattern）:一般使用关系表达式作为条件（非常多）
* x>10           判断变量x是否大于10
* x>=10          大于等于
* x<=10          小于等于
动作（Action）：
* 格式化输出
* 流程控制语句

*例*：
``` bash
awk '{printf $2 "\t" $6"\n"}' student.txt     # 输出文件第2,6列，&0代表整行。
df -h | awk '{print $1 "\t" $5 "\t" $6}'      #打印分区剩余空间，注意没有添加换行符哦
df -h | grep sda5 | awk '{print $5}' | cut -d "%" -f 1 #提取根分区的剩余空间（完整模式，输出一个整型字符串）
```
&emsp;**BEGIN** 在所有数据读取之前进行该条件的动作。在读取student文件2,6列之前，打赢一串字符。
``` bash
awk 'BEGIN{printf "this is a transcript\n"}{printf $2 "\t" $6 "\n"}' student.txt
```
&emsp;awk默认识别的分割符是制表符，那么怎样才能对passwd进行处理呢，就需要BEGIN来指定分割符（否则第一行不会处理，因为awk是先默认制表符读入一行，再处理文件）。例：
``` bash
awk 'BEGIN{FS=":"}{print $1 "\t" $3}' /etc/passwd
```
&emsp;**END**是在所有命令执行完成之后才会执行
``` bash
awk 'END{printf "The End \n"}{printf $2 "\t" $6 "\n"}' student.txt
```

**关系运算符**
``` bash
cat student.txt | grep -v Name | awk '$6>=87{printf $2 "\n"}'
```

#### 5.4 字符截取命令-sed命令
**sed**
``` bash
方式：
  sed [选项] '[动作]' 文件名
选项：
  -n            #一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。
  -e            #允许对输入数据应用多条sed命令编辑。
  -i            #用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出。
```
动作：
* a\            #追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用”\“代表数据未完结
* c\            #行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用”\“代表书库未完结。
* i\            插入，在当前行前插入一行或多行。出入多行时，除最后一行外，末尾需要用”\“代表数据未完结。
* d             删除，删除指定行
* p             打印，输出指定行
* s             字符串替换，用一个子妇产替换另外一个字符串。格式为”行范围s/旧字符/新字符/g“（和vim中的替换格式类似）

**例**:
``` bash
sed -n '2p' student.txt #查看文件的第二行,如果不加-n，整个文件都会输出，第二行就有两遍了
sed -i '2,4d' student.txt    #删除第2,4行数据,并保存到原文件中
sed '2a hello' student.txt  #在第二行后追加hello
sed '2i hello \
world' student.txt  #在第二行前面插入两行数据
sed '2c No such person' student.txt  #数据替换
```

**字符串替换**：
``` bash
方式：
  sed 's/旧字符串/新字符串/g' 文件名
```
**例**：
``` bash
sed '3s/79/00/g' student.txt  #在第三行中，把73换成99
sed -i '3s/74/99/g' student.txt    #sed操作的数据直接写入文件
sed -e 's/Liming//g;s/Gao//g' student.txt   #同时把”Liming“和”Gao“替换为空
```

#### 5.5 排序命令
**sort**
``` bash
方式：
  sort [选项] 文件名
选项：
  -f             #忽略大小写
  -n             #以数值型进行排序，默认使用字符串型排序
  -r             #反向排序
  -t             #指定分割符，默认分割符是制表符
  -k n[,m]       #按照指定的字段范围排序。从第n字段开始，m字段结束（默认到行尾）
```
**例**:
``` bash
sort /etc/passwd  #按字典对passwd文件进行排序
sort -t ":" -k 3,3 /etc/passwd  #以":"为分割符，以第三个字段进行排序（还是按字典的方式）
```

### 6. shell编程-常规语法
#### 6.1 判断
两种判断格式：
``` bash
test -e /root/install.log
[ -e /root/install.log ]    #shell常用
```

**1）按照文件类型进行判断**
* -d 文件      判断该文件是否存在，并且是否为目录文件（是目录为真）
* -e 文件      判断该文件是否存在（存在为真）
* -f 文件      判断该文件是否存在，并且是否为普通文件（是普通文件为真）
* -L 文件      判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真）
* -b 文件      判断该文件是否存在，并且是否为块设备文件（是块设备文件为真）
* -c 文件      判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真）
* -p 文件      判断该文件是否存在，并且是否为空（非空为真）
* -s 文件      判断该文件是否存在，并且是否为非空（非空为真）
* -S 文件      判断该文件是否存在，并且是否为套接字文件（是套接字文件为真）

例：<br>
``` bash
[ -d /root ] && echo "yes" || echo "no"
```

**2）按照文件权限进行判断**
* -r 文件       判断该文件是否真的存在，并且是否该文件拥有读权限（有读权限为真）
* -w 文件       判断该文件是否真的存在，并且是否该文件拥有写权限（有写权限为真）
* -x 文件       判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真）
* -u 文件       判断该文件是否存在，并且是否该文件拥有SUID权限
* -g 文件       判断该文件是否存在，并且是否该文件拥有SGID权限
* -k 文件       判断该文件是否存在，并且是否该文件拥有SBit权限

**3）两个文件之间的比较**
``` text
测试选项                  作用
文件1 -nt 文件2           判断文件1的修改时间是否比文件2的新（如果新则为真）
文件1 -ot 文件2           判断文件1的修改时间是否比文件2旧
文件1 -ef 文件2           判断文件1和文件2的Inode号是否一致，可以理解为两个文件是否为同一个文件，这个判断用于判断硬链接是很好的方法。
```

**4）两个整数之间的比较**
``` text
测试选项                   作用
整数1 -eq 整数2            判断整数1是否和整数2相等（相等为真）
整数1 -ne 整数2            判断整数1是否和这个数2不相等
整数1 -gt 整数2            判断整数1是否大于整数2
整数1 -lt 整数2            判断整数1是否小于整数2
整数1 -ge 整数2            判断整数1是否大于等于整数2
整数1 -le 整数2            判断整数1是否小于等于整数2
```

**5）字符串的判断**
``` text
测试选项                   作用
-z 字符串                  判断字符串是否为空
-n 字符串                  判断字符串是否为非空
字串1 == 字串2             判断字串1和字串2是否相等
字串1 != 字串2             判断字串1和字串2是否不相等
```

**6）多重条件判断**
``` text
测试选项                   作用
判断1 -a 判断2            逻辑与，判断1和判断2都城里，最终的结果才为真
判断1 -o 判断2            逻辑或，判断1和判断2有一个成立，最终的结果九尾真
! 判断                    逻辑非，是原始的判断式取反
```
#### 6.2 流程控制-if语句
**1）单分支if条件语句**
``` bash
if [ 条件判断式 ];then
   程序
fi
或
if [ 条件判断式 ]
then
   程序
fi
```
例：判断分区使用率<br>
``` bash
rate=$(df -h grep "/dev/sda3" | awk '{print $5}' | cut -d "%" -f1
#把分区使用率作为变量赋予变量rate
if [ $rate -ge 80 ]
then
   echo "Warning! /dev/sda3 is full"
fi
```

**2）双分支if条件语句**
``` bash
if [ 条件判断式 ]
then
   条件成立时，执行的程序
else
   条件不成立时，执行的另一个程序
fi
```

例子1：备份mysql数据库 <br>
``` bash
ntpdate asia.pool.ntp.org $>/dev/null
#同步系统时间，和亚洲时间同步
date=$(date +%y%m%d)
#把当前系统时间按照“年月日”格式赋予变量date
size=$(du -sh /var/lib/mysql)
#统计mysql数据库的大小，并把大小赋予size变量
if [ -d /tmp/dabak ]
then
    echo "Date : $date!" > /tmp/dbbak/dbinfo.txt
    echo "Data size : $size" >> /tmp/dbbak/dbinfo.txt
    cd /tmp/dbbak
    tar -zcf mysql-lib-$date.tar.gz  /var/lib/mysql dbinfo.txt &>/dev/null
    rm -rf /tmp/dbbak/dbinfo.txt
else
    mkdir /tmp/dbbak
    echo "Date : $date!" > /tmp/dbbak/dbinfo.txt
    cd /tmp/dbbak
    tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &> /dev/null
    rm -rf /tmp/dbbak/dbinfo.txt
fi
```

例子2：判断apache是否启动
``` bash
port=$(nmap -sT 192.168.1.156 | grep tcp | grep http | awk '{print $2}')
#使用nmap命令扫描服务器，并截取apache服务的状态，赋予变量port
if [ "$port" == "open" ]
then
   echo "$(date) httpd is ok!" >> /tmp/autostart-acc.log
else
   /etc/rc.d/init.d/httpd start $>/dev/null
   echo "$(date) restart httpd !!" >> /tmp/autostart-err.log
fi
```

**3）多分支if条件语句**
``` bash
if [ 条件判断式1 ]
then
   当条件判断式1成立时，执行程序1
elif [ 条件判断式2 ]
then
   当条件判断式2成立时，执行程序2
else
   当所有条件都不成立时，最后执行此程序
fi
```
例子：判断用户输入的是什么文件<br>
``` bash
read -p "Please input a filename:"  file
#接受键盘的输入，并赋予变量file
if [ -z "$file" ]
#判断file变量是否为空
then
   echo "Error,please input a filename"
   exit 1
elif
#判断file的值是否存在
then
   echo "Your input is not a file"
   exit 2
elif [ -f "$file" ]
#判断file的值是否为普通文件
then
   echo "$file is a regulare file!"
elif [ -d "$file" ]
#判断file的值是否为目录文件
then
   echo "$file is a directory"
else
   echo "$file is an other file!"
fi
```

#### 6.3 流程控制-case语句
&emsp;case语句和if...elif...else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系和不连续的情况，而if语句可以判断多种条件关系。<br>
``` bash
case $变量名 in
    "值1")
        如果变量值为1，则执行程序1
        ;;
    "值2”）
        如果变量值为2，则执行程序2
        ;;
    ...省略其它分支...
    *)
        如果变量的值都不是以上的值，则执行此程序
        ;;
esac
```

#### 6.4 流程控制-for循环
**1）语法1**
``` bash
for 变量 in 值1 值2 值3...
do
   程序
done
```
例子1：
``` bash
for time in morning noon afternoon evening
do
    echo "This time is $time!"
done
```
例子2：批量解压缩
``` bash
ls *.tar.gz > ls.log
for i in $(cat ls.log)
do
    tar -zxf $i &>/dev/null
done
rm -rf /lamp/ls.log
```
**2）语法2**
``` bash
s=0
for (( i=1;i<=100;i=1+1 ))
do
   s=$(( $s+$i ))
done
echo "The sum of 1+2+...+100 is : $s"
```
例子：批量添加指定数量的用户
``` bash
read -p "Please input user name:" -t 30 name
read -p "Please input the number of users:" -t 30 num
read -p "Please input the passwd of users:" -t 30 pass
if [ !-z "$name" -a ! -z "$num" -a !-z "$pass" ]
then
    y=$(echo $num | sed 's/[0-9]//g')
    if [ -z "$y" ]
    then
    for(( i=1;i<num;i=i+1 ))
    do
       /usr/sbin/useradd $name$i &>/dev/null
       echo $pass | /user/bin/passwd --stdin $name$i &>/dev/null
    done
    fi
fi
```

#### 6.4 流程控制-while循环与until循环
**1）while循环**<br>
&emsp;while循环是不定循环，也称作条件循环。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。这就和for的固定循环不太一样。<br>
``` bash
while [ 条件判断式 ]
do
    程序
done
```
例子：从1加到100到<br>
``` bash
i=1
s=0
while [ $i -le 100 ]
do
    s=$(( $s+$i ))
    i=$(( $i+1 ))
done
echo "The sum is: $s"
```

**2）until循环**<br>
&emsp;until循环，和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。<br>
